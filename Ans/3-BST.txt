
Q19) Check whether BST contains Dead End
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
bool solve(Node *root, int min, int max)
{
    if(!root) return false;
    if(min == max) return true;
    bool a = solve(root->left, min, root->data - 1);
    bool b = solve(root->right, root->data + 1, max);
    return a || b;
}

bool isDeadEnd(Node *root)
{
    return solve(root, 1, INT_MAX);
}
------------------------------------------------------------------------------
Q20) Check preorder is valid or not
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
int i;
Node *solve(int pre[], int n, int max_val)
{
    if(i == n || pre[i] > max_val) return NULL;
    Node *root = newNode(pre[i]);
    i++;
    root->left = solve(pre, n, root->data);
    root->right = solve(pre, n, max_val);
    
    return root;
}

Node* post_order(int pre[], int size)
{
    i = 0;
    return solve(pre, size, INT_MAX);
}
------------------------------------------------------------------------------
Q21) Largest BST in a Binary Tree [ V.V.V.V.V IMP ]
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vector<int> solve(Node *root)
{
    if(!root)                                           //base condition
        return {1, 0, INT_MAX, INT_MIN};
        
    if(!root->left && !root->right)                     //for leaf
        return {1, 1, root->data, root->data};
    
    vector<int> l = solve(root->left);
    vector<int> r = solve(root->right);
    
    if(l[0] && r[0])                                    //if left & right subtree is BST
    {
        if(l[3] < root->data && root->data < r[2])
        {
            int x = l[2];
            int y = r[3];
            if(x == INT_MAX) x = root->data;
            if(y == INT_MIN) y = root->data;
            return {1, l[1] + r[1] + 1, x, y};
        }
    }
    return {0, max(l[1],r[1]), 0, 0};			//if left or right subtree is not BST
}

int largestBst(Node *root)
{
    vector<int> v = solve(root);
    return v[1];
}
------------------------------------------------------------------------------
Q22) Flatten BST to sorted list | Increasing order
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>
using namespace std;

struct node 
{
	int data;
	node* left;
	node* right;
	node(int data)
	{
		this->data = data;
		left = NULL;
		right = NULL;
	}
};

void print(node *root)
{
    node *curr = root;
    while(curr)
    {
        cout << curr->data << " ";
        curr = curr->right;
    }
}

void inorder(node *root, node* &prev)
{
    if(root)
    {
        inorder(root->left, prev);
        prev->left = NULL;
        prev->right = root;
        prev = root;
        inorder(root->right, prev);
    }
}

node *flatten(node *root)
{
    node *dummy = new node(-1);
    node *prev = dummy;

    inorder(root, prev);
    root->left = NULL;
    prev->right = NULL;
    node *res = dummy->right;
    delete(dummy);
    return res;
}

int main()
{
	node* root = new node(5);
	root->left = new node(3);
	root->right = new node(7);
	root->left->left = new node(2);
	root->left->right = new node(4);
	root->right->left = new node(6);
	root->right->right = new node(8);
	
	node *ans = flatten(root);		// Calling required function
    	print(ans);
	return 0;
}
------------------------------------------------------------------------------