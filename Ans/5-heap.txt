                         **************Heap****************
////////////////////////////////////////////////////////////////////////////////////////////
1] STL for max min heap
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>
using namespace std;

int main ()
{
    	priority_queue<int> pq;                                         // Creates a max heap
	pq.push(5);
	pq.push(1);
	pq.push(10);
	pq.push(0);
	pq.push(20);

	// One by one extract items from max heap
	while (!pq.empty())
	{
		cout << pq.top() << " ";
		pq.pop();
	}
    	return 0;
    
	priority_queue<int, vector<int>, greater<int>> pq;              // Creates a min heap
	pq.push(5);
	pq.push(1);
	pq.push(10);
	pq.push(0);
	pq.push(20);

	// One by one extract items from max heap
	while (!pq.empty())
	{
		cout << pq.top() << " ";
		pq.pop();
	}
    	return 0;
}
--------------------------------------------------------------------------------------------
2] set
Properties:
1. The set stores the elements in sorted order.
2. All the elements in a set have unique values.
3. The value of the element cannot be modified once it is added to the set, 
   though it is possible to remove and then add the modified value of that element. 
   Thus, the values are immutable.
4. Sets follow the "Binary search tree implementation".
5. The values in a set are unindexed.
--------------------------------------------------------------------------------------------
Q1) Building Max_Heap from Array
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <iostream>
using namespace std;

void heapify(int arr[], int n, int i)
{
	int largest = i; 
	int l = 2 * i + 1;
	int r = 2 * i + 2;

	if (l < n && arr[l] > arr[largest])                 // If left child is larger than root
		largest = l;

	if (r < n && arr[r] > arr[largest])                 // If right child is larger than largest so far
		largest = r;

	if (largest != i)                                   // If largest is not root
	{
		swap(arr[i], arr[largest]);
		heapify(arr, n, largest);                   // Recursively heapify the affected sub-tree
	}
}

void buildHeap(int arr[], int n)                            // Function to build a Max-Heap from the given array
{
	int startIdx = (n / 2) - 1;                         // Index of last non-leaf node

	// Perform reverse level order traversal
	// from last non-leaf node and heapify
	// each node
	for (int i = startIdx; i >= 0; i--) 
	{
		heapify(arr, n, i);
	}
}

void printHeap(int arr[], int n)
{
	cout << "Array representation of Heap is:\n";

	for(int i = 0; i < n; ++i)
		cout << arr[i] << " ";
}

int main()
{
    int arr[] = { 1, 3, 5, 4, 6, 13, 10, 9, 8, 15, 17 };
    int n = sizeof(arr) / sizeof(arr[0]);

	buildHeap(arr, n);
    printHeap(arr, n);
    return 0;
}
--------------------------------------------------------------------------------------------
void heapify(vector<int> &arr, int n, int i)			//coding ninjas- max_heap
{
    int largest = i;
    int left = 2*i + 1;
    int right = 2*i +2;
    if(left < n && arr[largest] < arr[left])
        largest = left;
    
    if(right < n && arr[largest] < arr[right])
        largest = right;
    
    if(largest != i)
    {
        swap(arr[largest], arr[i]);
        heapify(arr, n, largest);
    }
}
vector<int> buildHeap(vector<int> arr, int n)
{	 
    for(int i=(n/2)-1; i>=0; i--)
    {
        heapify(arr, n, i);
    }
    return arr;
}
---------------------------------------------------------------------------------------------
void heapify(vector<int> &arr, int n, int i)			//coding ninjas- min_heap
{
    int smallest = i;
    int l = 2*i + 1;
    int r = 2*i + 2;
    if(l<n && arr[smallest] > arr[l])
        smallest = l;
    if(r<n && arr[smallest] > arr[r])
        smallest = r;
    
    if(smallest != i)
    {
        swap(arr[smallest], arr[i]);
        heapify(arr, n, smallest);
    }
}
vector<int> buildMinHeap(vector<int> &arr)
{
    int n = arr.size();
    for(int i=(n/2)-1; i>=0; i--)
    {
        heapify(arr, n, i);
    }
    return arr;
}
---------------------------------------------------------------------------------------------
Q2) Sort an Array using heap. (HeapSort)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <iostream>
using namespace std;

void heapify(int arr[], int n, int i)
{
	int largest = i; 
	int l = 2 * i + 1;
	int r = 2 * i + 2;

	if (l < n && arr[l] > arr[largest])                 // If left child is larger than root
		largest = l;

	if (r < n && arr[r] > arr[largest])                 // If right child is larger than largest so far
		largest = r;

	if (largest != i)                                   // If largest is not root
	{
		swap(arr[i], arr[largest]);
		heapify(arr, n, largest);                   // Recursively heapify the affected sub-tree
	}
}

void heapSort(int arr[], int n)
{
	for (int i = n / 2 - 1; i >= 0; i--)
		heapify(arr, n, i);

	for (int i=n-1; i>0; i--)               // One by one extract an element from heap
	{
	    swap(arr[0], arr[i]);               // Move current root to end
            heapify(arr, i, 0);		        // call max heapify on the reduced heap
	}
}

int main()
{
	int arr[] = { 12, 11, 13, 5, 6, 7 };
	int n = sizeof(arr) / sizeof(arr[0]);

	heapSort(arr, n);

	cout << "Sorted array is \n";
	for (int i = 0; i < n; ++i)
		cout << arr[i] << " ";
	return 0;
}
---------------------------------------------------------------------------------------------
Q3) Maximum of all subarrays of size k.
{IPL 2021 - Match Day 2}
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vector<int> max_of_subarrays(vector<int> arr, int n, int k) 
{
    priority_queue<pair<int,int>> pq;				//for max_heap
    for(int i=0; i<k; i++)
    {
        pq.push({arr[i], i});
    }
    
    vector<int> v;
    v.push_back(pq.top().first);
    
    for(int i=k; i<n; i++)
    {
        pq.push({arr[i], i});
        while(pq.top().second <= i-k)
        {
            pq.pop();
        }
        v.push_back(pq.top().first);
    }
    return v;
}
---------------------------------------------------------------------------------------------
Q4) 	“k” largest element in an array
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vector<int> kLargest(int arr[], int n, int k) 
{
	vector<int> v;
	priority_queue<int, vector<int>, greater<int>> pq;       //for min_heap
	
	for(int i=0; i<n; i++)
	{
	    pq.push(arr[i]);
	  
	    if(pq.size() > k)
	    {
	        pq.pop();
	    }
	}
	
	while(!pq.empty())
	{
	    v.push_back(pq.top());
	    pq.pop();
	}
	
	reverse(v.begin(), v.end());
	return v;
}

"""""""""""""""""""""""""""""
Input:
N = 5, K = 2
Arr[] = {12, 5, 787, 1, 23}
Output: 787 23
---------------------------------------------------------------------------------------------
Q5) Kth smallest and largest element in an unsorted array
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <iostream>			//brute force
#include <algorithm>
using namespace std;

int main()
{
    int arr[] = { 12, 3, 5, 7, 19, 34, 55 };
    int n = sizeof(arr) / sizeof(arr[0]);
    int k = 2;
    
    sort(arr, arr+n);
    
    cout << "kth largest element in array : " << arr[n-k];
    cout << endl;
    cout << "kth smallest element in array : " << arr[k-1];
    return 0;
}
---------------------------------------------------------------------------------------------
#include <iostream>			//STL for BST(asce. & desc. order)
#include <iterator>
#include <set>
using namespace std;

int main()
{
    int arr[] = { 12, 3, 5, 7, 19, 34, 55 };
    int n = sizeof(arr) / sizeof(arr[0]);
    int k = 3;
    
    set<int, greater<int>> s(arr, arr+n);               // ----(1)
    set<int> :: iterator itr = s.begin();               // s.begin() returns a pointer to first element in the set
    
    advance(itr, k-1);                                  // itr points to kth element in set
    cout << "kth largest element in array : " << *itr;
    
    // set<int> s(arr, arr+n);                          // ----(2)
    // set<int> :: iterator itr = s.begin();            // s.begin() returns a pointer to first element in the set
    
    // advance(itr, k-1);                               // itr points to kth element in set
    // cout << "kth smallest element in array : " << *itr;
    
	return 0;
}
---------------------------------------------------------------------------------------------
class Solution							//gfg practice
{
    public:
    // arr : given array
    // l : starting index of the array i.e 0
    // r : ending index of the array i.e size-1
    // k : find kth smallest element and return using this function
int kthSmallest(int arr[], int l, int r, int k) 
{
    priority_queue<int> pq;
    for(int i=0; i<=r; i++)
    {
        pq.push(arr[i]);
        if(pq.size() > k)
        {
            pq.pop();
        }
    }
    return pq.top();
}
};

""""""""""""""""""""""""""
Input:
N = 5
arr[] = 7 10 4 20 15
K = 4
Output : 15
---------------------------------------------------------------------------------------------
class Solution 							//leetcode practice
{
public:
    int findKthLargest(vector<int>& nums, int k) 
    {
        int n = nums.size();
        priority_queue<int, vector<int>, greater<int>> pq;
        for(int i=0; i<n; i++)
        {
            pq.push(nums[i]);
            if(pq.size() > k)
            {
                pq.pop();
            }
        }
        return pq.top(); 
    }
};
""""""""""""""""""""""""""
Input:
N = 5
arr[] = 7 10 4 20 15
K = 3
Output : 10
---------------------------------------------------------------------------------------------
Q6) Merge k Sorted Arrays 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
public:							//most efficient
typedef pair<int, pair<int, int>> ppi;				//defined by user
vector<int> mergeKArrays(vector<vector<int>> arr, int K)
{
    vector<int> ans;
    priority_queue<ppi, vector<ppi>, greater<ppi>> pq;
       
    for(int i=0; i<arr.size(); i++)
    {
        pq.push({arr[i][0], {i,0}});
    }
       
    while(!pq.empty())
    {
        ppi minimum = pq.top();
        pq.pop();
        ans.push_back(minimum.first);
           
        int i = minimum.second.first;
        int j = minimum.second.second;
           
        if(j+1<arr[i].size())
        {
            pq.push({arr[i][j+1], {i,j+1}});
        }
    }
    return ans;
}
---------------------------------------------------------------------------------------------
class Solution						//by min heap
{
    public:
    vector<int> mergeKArrays(vector<vector<int>> arr, int K)
    {
        vector<int> v;
        priority_queue<int, vector<int>, greater<int>> pq;          //for min_heap

        for(auto x : arr)
        {
            for(int i : x)
            {
                pq.push(i);
            }
        }
        
        while(!pq.empty())
        {
            v.push_back(pq.top());
            pq.pop();
        }
        
        return v;
    }
};
---------------------------------------------------------------------------------------------
    vector<int> mergeKArrays(vector<vector<int>> arr, int K)		//brute force
    {
        vector<int> v;
        
        for(int i=0; i<K; i++)
        {
            for(int j=0; j<K; j++)
            {
                v.push_back(arr[i][j]);
            }
        }
        
        sort(v.begin(), v.end());
        return v;
    }
---------------------------------------------------------------------------------------------
Q7) Merge two binary Max heaps
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution
{
    public:
    void heapify(vector<int> &v, int n, int i)
    {
        int largest = i;
        int l = 2*i + 1;
        int r = 2*i + 2;
        if(l<n && v[l] > v[largest])
            largest = l;
            
        if(r<n && v[r] > v[largest])
            largest = r;
            
        if(largest != i)
        {
            swap(v[largest], v[i]);
            heapify(v, n, largest);
        }
    }
    
    vector<int> mergeHeaps(vector<int> &a, vector<int> &b, int n, int m) 
    {
        vector<int> v;
        for(auto i : a)                 //push ele of first binary max heap in v
            v.push_back(i);
            
        for(auto i : b)                 //push ele of second binary max heap in v
            v.push_back(i);
            
        int siz = v.size();
        
        for(int i=siz/2-1; i>=0; i--)
            heapify(v, siz, i);
            
        return v;
    }
};

""""""""""""""""""""""""""
Input  : 
n = 4 m = 3
a[] = {10, 5, 6, 2}, 
b[] = {12, 7, 9}
Output : 
{12, 10, 9, 2, 5, 7, 6}
---------------------------------------------------------------------------------------------
    vector<int> mergeHeaps(vector<int> &a, vector<int> &b, int n, int m) 
    {
       vector<int> v;
       
       a.insert(a.end(), b.begin(), b.end());
       
       priority_queue<int> pq;                  	//max_heap
       
       for(int i=0; i<a.size(); i++)
       {
           pq.push(a[i]);
       }
       
       while(!pq.empty())
       {
           v.push_back(pq.top());
           pq.pop();
       }
       return v;
    }

"""""""""""""""""""""""""""""
Input  : 
n = 4 m = 3
a[] = {10, 5, 6, 2}, 
b[] = {12, 7, 9}
Output : 
{12, 10, 9, 2, 5, 6, 7}
---------------------------------------------------------------------------------------------
Q8) K-th Largest Sum Contiguous Subarray
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution							//brute force
{
public:
int kthLargest(vector<int> &Arr,int N,int K)
{
    vector<int> v;

    for(int i=0; i<N; i++)
    {
        int sum = 0;
        for(int j=i; j<N; j++)
        {
            sum = sum + Arr[j];
            v.push_back(sum);
        }
    }
    sort(v.begin(), v.end());
    reverse(v.begin(), v.end());
    return v[K-1];
}
};
---------------------------------------------------------------------------------------------
class Solution							//efficient sol
{
public:
int kthLargest(vector<int> &Arr,int N,int K)
{
    priority_queue<int, vector<int>, greater<int>> pq;		//min_heap
    
    for(int i=0; i<N; i++)
    {
        int sum = 0;
        for(int j=i; j<N; j++)
        {
            sum = sum + Arr[j];
            if(pq.size() < K)
            {
                pq.push(sum);
            }
            else
            {
                if(pq.top() < sum)
                {
                    pq.pop();
                    pq.push(sum);
                }
            }
        }
    }
    return pq.top();
}
};
---------------------------------------------------------------------------------------------
Q9)  Reorganize String
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 							//Leetcode
{
public:
    string reorganizeString(string s) 
    {
        string ans = "";
        int count[26] = {0};
        for(int i=0; i < s.length(); i++)
        {
            count[s[i] - 'a']++;
        }
        
        typedef pair<int, char> ppi;
        priority_queue<ppi> pq;
        
        for(char c='a'; c <= 'z'; c++)
        {
            int val = c - 'a';
            if(count[val])
                pq.push({count[val], c});
        }
        
        ppi prev = {-1, '#'};
        while(!pq.empty())
        {
            ppi x = pq.top();
            pq.pop();
            ans = ans + x.second;
            x.first--;
            if(prev.first > 0)
                pq.push(prev);
            prev = x;
        }
        
        if(ans.length() != s.length()) return "";	//in gfg practice, return "-1";
        else return ans;
    }
};
---------------------------------------------------------------------------------------------
Q10) Kadane's Algorithm
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution
{
    public:
    // arr: input array
    // n: size of array
    //Function to find the sum of contiguous subarray with maximum sum.
    long long maxSubarraySum(int arr[], int n)
    {
        int maximum = INT_MIN;
        int curr_max = 0;
        for(int i=0; i<n; i++)
        {
            curr_max = curr_max + arr[i];
            maximum = max(curr_max, maximum);
            if(curr_max < 0) curr_max = 0;
        }
        return maximum;
        
    }
};
---------------------------------------------------------------------------------------------
Q11) Merge K sorted linked lists
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution
{
  public:
Node * mergeKLists(Node *arr[], int K)
{
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > pq;
    for(int i=0; i<K; i++)
    {
        if(arr[i])
            pq.push({arr[i]->data, i});
    }
    
    Node *res = new Node(0);
    Node *head = res;
    while(!pq.empty())
    {
        head->next = new Node(pq.top().first);
        head = head->next;
        int r = pq.top().second;
        pq.pop();
        
        if(arr[r]->next)
        {
            pq.push({arr[r]->next->data, r});
            arr[r]->next = arr[r]->next->next;
        }
    }
    return res->next;
}
---------------------------------------------------------------------------------------------
Q12) Check if a Binary Tree is Heap
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 
{
  public:
    bool maxorder(Node* root)
    {
        if(!root->left && !root->right) return true;
 
        else if(!root->right)
            return root->data > root->left->data;
        
        /*If it's left and right is not NULL check root->left and root->right and 
          data of both left and right is greater*/
        else
            return maxorder(root->left) && 
                   maxorder(root->right) && 
                   root->data > root->left->data && 
                   root->data > root->right->data;
    }
  
    bool isCBT(Node* root,int i,int size)
    {
        if(!root) return true;
      
        /*If size is lesser than the index value means that there is some node exist 
          which is not following CBT properity*/        
        else if(i >= size) return false;
      
        //check for both left and right      
        else
            return isCBT(root->left, 2*i+1, size) && isCBT(root->right, 2*i+2, size);
    }
  
    int count(Node* root)
    {
        if(!root) return 0;
        return 1 + count(root->left) + count(root->right);
    }
    
    bool isHeap(Node* root)                                              //isHeap
    {
        int size=count(root);
        return isCBT(root, 0, size) && maxorder(root);
    }
};
---------------------------------------------------------------------------------------------
Q13) Connect “n” ropes with minimum cost
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution
{
    public:
    //Function to return the minimum cost of connecting the ropes.
    long long minCost(long long arr[], long long n) 
    {
        priority_queue<long long, vector<long long>, greater<long long>> pq;
        
        for(int i=0; i<n; i++)
        {
            pq.push(arr[i]);
        }
        
        long long cost = 0;
        while(pq.size() >= 2)
        {
            long long a = pq.top();
            pq.pop();
            long long b = pq.top();
            pq.pop();
            
            cost = cost + a + b;
            pq.push(a + b);
        }
        
        return cost;
    }
};
---------------------------------------------------------------------------------------------
Q14) BST to max heap 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution							//gfg practice
{
  public:
void inordertraversal(Node *root, vector<int> &v)
{
    if(!root) return;
    
    inordertraversal(root->left, v);
    v.push_back(root->data);
    inordertraversal(root->right, v);
}

void solve(Node *root, vector<int> &v, int &i)
{
    if(!root) return;
    
    solve(root->left, v, i);
    solve(root->right, v, i);
    root->data = v[i];
    i++;
}

void convertToMaxHeapUtil(Node* root)
{
    vector<int> v;
    int i = 0;
    
    inordertraversal(root, v);
    solve(root, v, i);

} 
};
---------------------------------------------------------------------------------------------
Q15) BST to min heap 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
void inordertraversal(BinaryTreeNode *root, vector<int> &v)		//coding ninjas
{
    if(!root) return;
    inordertraversal(root->left, v);
    v.push_back(root->data);
    inordertraversal(root->right, v);
}

void solve(BinaryTreeNode *root, vector<int> &v, int &i)
{
    if(!root) return;
    root->data = v[i];
    i++;
    solve(root->left, v, i);
    solve(root->right, v, i);
}

BinaryTreeNode* convertBST(BinaryTreeNode* root)
{
    vector<int> v;
    int i = 0;
    
    inordertraversal(root, v);
    solve(root, v, i);
    return root;
}
---------------------------------------------------------------------------------------------
Q16) 	Convert min heap to max heap
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
void heapify(long *arr, int i, int n)				//coding ninjas
{
    int largest = i;
    int l = 2*i + 1;
    int r = 2*i + 2;
    
    if(l < n && arr[largest] < arr[l])
        largest = l;
    if(r < n && arr[largest] < arr[r])
        largest = r;
    
    if(largest != i)
    {
        swap(arr[largest], arr[i]);
        heapify(arr, largest, n);
    }
}

void minHeapToMaxHeap(long *arr, int n)
{
    for(int i = n/2-1; i>=0; i--)
        heapify(arr, i, n);
}
---------------------------------------------------------------------------------------------
Q17) 	Minimum sum of two numbers formed from digits of an array
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution
{   
public:
    string solve(int arr[], int n) 
    {
        sort(arr, arr + n);
        string s1 = "", s2 = "";
        for(int i=0; i<n; i=i+2)                    //make s1
            s1 = s1 + to_string(arr[i]);
            
        for(int i=1; i<n; i=i+2)                    //make s2
            s2 = s2 + to_string(arr[i]);
            
        if(s1.length() != s2.length())              //if arr size is odd, make s1 & s2 same size
        {
            reverse(s2.begin(), s2.end());
            s2 = s2 + to_string(0);
            reverse(s2.begin(), s2.end());
        }
        
        int i = s1.length() - 1;                    // or s2.length() - 1
        int sum = 0;
        int carry = 0;
        string ans = "";
        
        while(i >= 0)
        {
            int a = s1[i] - '0';
            int b = s2[i] - '0';
            sum = a + b + carry;
            carry = sum / 10;
            ans = ans + to_string(sum % 10);
            i--;
        }
        if(carry) ans = ans + to_string(1);
        
        reverse(ans.begin(), ans.end());
        while(ans[0] == '0')                        //if ans starts from '0', erase it
        {
            ans.erase(ans.begin());
        }
        return ans;
    }
};
---------------------------------------------------------------------------------------------