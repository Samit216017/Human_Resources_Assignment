                    		   ******Backtracking******
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Q1) Rat in a Maze Problem - I
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
    public:
    void solve(vector<string> &v, vector<vector<int>> &M, int n, int i, int j, string s)
    {
        if(i<0 || j<0 || i>=n || j>=n || M[i][j]<=0)
            return;
            
        if(i==n-1 && j==n-1)
        {
            v.push_back(s);
            return;
        }
        M[i][j] = -1;
        solve(v, M, n, i+1, j, s + "D");
        solve(v, M, n, i-1, j, s + "U");
        solve(v, M, n, i, j+1, s + "R");
        solve(v, M, n, i, j-1, s + "L");
        M[i][j] = 1;
    }
    
    vector<string> findPath(vector<vector<int>> &M, int n) 
    {
        vector<string> v;
        if(M[0][0] == 0) return {};
        string s = "";
        solve(v, M, n, 0, 0, s);
        return v;
    }
};                   	
---------------------------------------------------------------------------------------------
Q2) N-Queen problem
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
public:

    bool isSafe(int row, int col, vector<vector<int>> board, int n)
    {
        int temp_row = row, temp_col = col;
        while(row>=0 && col>=0)                         //upper back diag
        {
            if(board[row][col]==1) return false;
            row--;
            col--;
        }
        
        row = temp_row, col = temp_col;
        while(col >=0)                                  //hori back
        {
            if(board[row][col]==1) return false;
            col--;
        }
        
        row = temp_row, col = temp_col;
        while(col >=0 && row<n)                         //down back diag
        {
            if(board[row][col]==1) return false;
            col--;
            row++;
        }        
        return true;
    }

    void solve(int col, int n, vector<vector<int>> &ans, vector<vector<int>>&board)
    {
        if(col==n)                                      //base condition
        {
            vector<int> temp;
            for(int i=0;i<n;i++)
            {
                for(int j=0;j<n;j++)
                {
                    if(board[i][j]==1) temp.push_back(j+1);
                }
            }
           
            ans.push_back(temp);
        }
       
        for(int row=0; row<n; row++)
        {
            if(isSafe(row, col, board, n) == true)
            {
                board[row][col] = 1;
                solve(col+1, n, ans, board);
                board[row][col] = 0;                    //backtracking
            }
        }
    }
    
    vector<vector<int>> nQueen(int n)                           //main fun
    {
        vector<vector<int>> ans;
        vector<vector<int>> board(n, vector<int>(n, 0));
      
        solve(0, n, ans, board);
        sort(ans.begin(), ans.end());
        return ans;
    }
};                 	
---------------------------------------------------------------------------------------------
Q3) Word Break - Part 2
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient solo
{
public:
    vector<string> ans;
    
    bool wordAvailable(string temp, vector<string> &dict, int n)		//helper-1
    {
        for(int i=0; i<n; i++)
        {
            if(dict[i] == temp) return true;
        }
        return false;
    }
    
    void solve(int n, vector<string> &dict, string s, int start, string sub)	//helper-2
    {
        if(start == s.size())
        {
            ans.push_back(sub.substr(0, sub.size()-1));
            return;
        }
        string temp = "";
        for(int i=start; i<s.size(); i++)
        {
            temp = temp + s[i];
            if(wordAvailable(temp, dict, n))
                solve(n, dict, s, i+1, sub + temp + " ");
        }
    }
    
    vector<string> wordBreak(int n, vector<string>& dict, string s)		//main fun
    {
        string sub = "";
        solve(n, dict, s, 0, sub);
        return ans;
    }
};                	
---------------------------------------------------------------------------------------------
Q4) Remove Invalid Parentheses
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 								//gfg efficient sol
{
  public:
    void solve(string s, vector<string> &ans, int rem, unordered_map<string, bool> &mp)  //helper-1
    {
        if(mp[s] == true) return;
        mp[s] = true;
        
        if(rem == 0)
        {
            int rem_needed = findRemoval(s);
            if(rem_needed == 0)
            {
                ans.push_back(s);
                return;
            }
        }
        
        for(int i=0; i<s.size(); ++i)
        {
            string left = s.substr(0, i);
            string right = s.substr(i+1);
            string join = left + right;
            
            solve(join, ans, rem-1, mp);
        }
        return;
    }
    
    int findRemoval(string s)								//helper-2
    {
        stack<char> st;
        for(int i=0; i<s.size(); i++)
        {
            if(s[i] == '(') 
                st.push(s[i]);
            
            else if(s[i] == ')')
            {
                if(!st.empty() && st.top() == '(')
                    st.pop();
                else
                    st.push(s[i]);
            }
        }
        return st.size();
    }
    
    vector<string> removeInvalidParentheses(string s) 					//main fun
    {
        vector<string> ans;
        int rem = findRemoval(s);                           //min #of removals
        unordered_map<string, bool> mp;
        solve(s, ans, rem, mp);
        sort(ans.begin(), ans.end());
        return ans;
    }
};               	
---------------------------------------------------------------------------------------------
class Solution 								//Leetcode efficient sol
{
public:
    
    void solve(string s, vector<string> &ans, int rem, unordered_map<string, bool> &mp)
    {
        if(mp[s] == true) return;
        mp[s] = true;
        
        if(rem == 0)
        {
            int rem_needed = findRemoval(s);
            if(rem_needed == 0)
                ans.push_back(s);
            return;
        }
        
        for(int i=0; i<s.size(); ++i)
        {
            string left = s.substr(0, i);
            string right = s.substr(i+1);
            string join = left + right;
            
            solve(join, ans, rem-1, mp);
        }
        return;
    }
    
    int findRemoval(string s)
    {
        stack<char> st;
        for(int i=0; i<s.size(); i++)
        {
            if(s[i] == '(') 
                st.push(s[i]);
            
            else if(s[i] == ')')
            {
                if(!st.empty() && st.top() == '(')
                    st.pop();
                else
                    st.push(s[i]);
            }
        }
        return st.size();
    }
    
    vector<string> removeInvalidParentheses(string s) 
    {
        vector<string> ans;
        int rem = findRemoval(s);                           //min #of removals
        unordered_map<string, bool> mp;
        solve(s, ans, rem, mp);
        return ans;
    }
};
---------------------------------------------------------------------------------------------
Q5) Solve the Sudoku 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
//link:- https://www.youtube.com/watch?v=8lWxaRviJBA&ab_channel=CodeHelp-byBabbar
class Solution 								//gfg efficient sol
{
    public:
     
    bool isSafe(int grid[N][N], int r, int c, int val)          //helper fun
    {
        for(int i=0; i<N; i++)
        {
            if(grid[r][i] == val) return false;
            if(grid[i][c] == val) return false;
            
            if(grid[3*(r/3) + (i/3)][3*(c/3) + (i%3)] == val) return false;
        }
        return true;
    }
    
    
    bool SolveSudoku(int grid[N][N])                //Function to find a solved Sudoku.
    { 
        for(int i=0; i<N; i++)
        {
            for(int j=0; j<N; j++)
            {
                if(grid[i][j] == 0)
                {
                    for(int val=1; val<=N; val++)
                    {
                        if(isSafe(grid, i, j, val))
                        {
                            grid[i][j] = val;
                        
                            if(SolveSudoku(grid) == true)
                                return true;
                            else
                                grid[i][j] = 0;				//--->backtracking
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }
    
    
    void printGrid (int grid[N][N])                 //Function to print Sudoku sol.
    {
        for(int i=0; i<N; i++)
        {
            for(int j=0; j<N; j++)
            {
                cout << grid[i][j] << " ";
            }
        }
    }
};                    	
---------------------------------------------------------------------------------------------
Q6) M-Coloring Problem
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
practice link:-https://practice.geeksforgeeks.org/problems/m-coloring-problem-1587115620/1

class Solution								//gfg efficient sol
{
public:
    bool isSafe(int node, int col[], bool graph[101][101], int n, int cc)	//helper-1
    {
        for(int i=0; i<n; i++)
        {
            if(graph[i][node] == 1 && col[i] == cc)
                return false;
        }
        return true;
    }
    
    bool solve(int node, int col[], int m, int n, bool graph[101][101])		//helper-2
    {
        if(node == n) return true;
        
        for(int i=1; i<= m; i++)
        {
            if(isSafe(node, col, graph, n, i))
            {
                col[node] = i;
                if(solve(node+1, col, m, n, graph))
                    return true;
                col[node] = 0;                              //--->backtracking
            }
        }
        return false;
    }
    
    bool graphColoring(bool graph[101][101], int m, int n) 			//main fun
    {
        int col[n] = {0};
        if(solve(0, col, m, n, graph))
            return true;
        else
            return false;
    }
};
---------------------------------------------------------------------------------------------
Q7) Find all possible palindromic partitions of a String
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 								//gfg efficient sol
{
  public:
    bool isPalindrome(string s)							//helper-1
    {
        int n = s.size();
        int i=0; 
        int j=n-1;
        while(i <= j)
        {
            if(s[i] != s[j])
            {
                return false;
            }
            i++;
            j--;
        }
        return true;
    }
    
    void solve(string s, vector<string> &temp, vector<vector<string>> &ans)	//helper-2
    {
        int n = s.size();
        if(n == 0) 
        {
            ans.push_back(temp);
            return;
        }
        
        for(int i=0; i<n; i++)
        {
            string sub = s.substr(0, i+1);
            if(isPalindrome(sub))
            {
                temp.push_back(sub);
                string ros = s.substr(i+1);
                solve(ros, temp, ans);
                temp.pop_back();				//--->backtracking
            }
        }
    }
    
    vector<vector<string>> allPalindromicPerms(string s) 			//main fun
    {
        vector<vector<string>> ans;
        vector<string> temp;
        solve(s, temp, ans);
        
        return ans;
    }
};
---------------------------------------------------------------------------------------------
Q8) The Knight’s tour problem
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include<bits/stdc++.h>
using namespace std;
#define N 8

bool IsSafe(int sol[N][N], int next_row, int next_col)                              //helper-1
{
    return (next_row>=0 && next_row<N && 
            next_col>=0 && next_col<N  && 
            sol[next_row][next_col]==-1);
}

int solve(int sol[N][N],int x_move[8],int y_move[8], int row,int col,int move)      //helper-2
{
    if(move == N*N) return 1;
   
    int next_row, next_col;
   
    for(int k=0; k<8; k++)
    {
        next_row = row + x_move[k];
        next_col = col + y_move[k];
        if(IsSafe(sol, next_row, next_col))
        {
            sol[next_row][next_col] = move;

            if(solve(sol, x_move, y_move , next_row, next_col, move+1)) return true;
            else sol[next_row][next_col] = -1;                               //--->backtracking
        }
    }
    return false;
}

int KnightTour()                                                                    //helper-3
{
    int sol[N][N];
    for(int i=0; i<N; i++)
    {
        for(int j=0; j<N; j++)
        {
            sol[i][j] = -1;
        }
    }
    sol[0][0] = 0;
    int x_move[8] = {2, 1, -1, -2, -2, -1, 1, 2};
    int y_move[8] = {1, 2, 2, 1, -1, -2, -2, -1};
    if(solve(sol, x_move, y_move, 0, 0, 1)==false)
    {
        cout << "The solution does not exist " << endl;
        return 0;
    }
    else
    {
        for(int i=0; i<N; i++)
        {
            for(int j=0; j<N; j++)
            {
                cout << " " << setw(2) << sol[i][j] << " ";
            }
            cout << endl;
        }
        return true;
    }    
}

int main()                                                                          //main fun
{
    KnightTour();
    return 0;
}

o/p:-
  0  59  38  33  30  17   8  63 
 37  34  31  60   9  62  29  16 
 58   1  36  39  32  27  18   7 
 35  48  41  26  61  10  15  28 
 42  57   2  49  40  23   6  19 
 47  50  45  54  25  20  11  14 
 56  43  52   3  22  13  24   5 
 51  46  55  44  53   4  21  12 
---------------------------------------------------------------------------------------------
Q9) Tug of War
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>
using namespace std;

vector<int> a1, a2;
void TugOfWar(int *arr, int n, vector<int>s1, vector<int> s2, int sum1, int sum2, int indx, int &minDiff)
{
    if(indx == n)                                                               //base condition
    {
        int curr_diff = abs(sum1 - sum2);
        if(curr_diff < minDiff)
        {
            minDiff = curr_diff;
            a1.clear();
            a2.clear();
            for(auto x:s1)                                  //store previous val of s1
                a1.push_back(x);
                
            for(auto x : s2)                                //store previous val of s2
                a2.push_back(x);
        }
        return;
    }
    
    if(s1.size() < (n+1)/2)
    {
        s1.push_back(arr[indx]);
        TugOfWar(arr, n, s1, s2, sum1+arr[indx], sum2, indx+1, minDiff);
        s1.pop_back();                                                          //--->backtracking
    }
    
    if(s2.size() < (n+1)/2)
    {
        s2.push_back(arr[indx]);
        TugOfWar(arr, n, s1, s2, sum1, sum2+arr[indx], indx+1, minDiff);
        s2.pop_back();                                                          //--->backtracking
    }
}

int main()
{
    int arr[] = {5, 2, 3};
    int n = sizeof(arr)/sizeof(arr[0]);
    vector<int> s1, s2;
    int minDiff = INT_MAX;
    TugOfWar(arr, n, s1, s2, 0, 0, 0, minDiff);
    
    cout << "set1: ";                                   //print set1
    for(auto x: a1)
        cout << x << " ";
        
    cout << "\nset2: ";                                 //print set2
    for(auto x : a2)
        cout << x << " ";
}

o/p:-
set1: 5 
set2: 2 3 
---------------------------------------------------------------------------------------------
Q10) Find shortest safe route in a path with landmines
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>
using namespace std;
#define R 12
#define C 10


bool isSafe(int mat[R][C], int visited[R][C], int i, int j)                         //helper-1
{
    return (i >= 0 && i < R && j >= 0 && j < C &&
            mat[i][j] == 1 && visited[i][j] == 0);
}


void solve(int mat[R][C], int visited[R][C], int r, int c, int len, int &minlen)    //helper-2
{
    if(c == C-1)                                  //base condition
    {
        if(len < minlen) minlen = len;
        return;
    }
    if(len > minlen) return;                    //bcz time optimization
    
    visited[r][c] = 1;
    if(isSafe(mat, visited, r+1, c)) solve(mat, visited, r+1, c, len+1, minlen);
    if(isSafe(mat, visited, r-1, c)) solve(mat, visited, r-1, c, len+1, minlen);
    if(isSafe(mat, visited, r, c+1)) solve(mat, visited, r, c+1, len+1, minlen);
    if(isSafe(mat, visited, r, c-1)) solve(mat, visited, r, c-1, len+1, minlen);
    visited[r][c] = 0;									//--->backtracking
}


void findShortestPath(int mat[R][C], int minlen, int len)                           //helper-3
{
    for(int i=0; i<R; i++)
    {
        for(int j=0; j<C; j++)
        {
            if(mat[i][j] == 0)
            {
                if(i-1 >= 0) mat[i-1][j] = -1;
                if(i+1 < R) mat[i+1][j] = -1;
                if(j-1 >= 0) mat[i][j-1] = -1;
                if(j+1 < C) mat[i][j+1] = -1;
                
            }
        }
    }
    
    for(int i=0; i<R; i++)
    {
        for(int j=0; j<C; j++)
        {
            if(mat[i][j] == -1) mat[i][j] = 0;
        }
    }
    
    int visited[R][C];
    int col = 0;
    for(int i=0; i<R; i++)
    {
        if(mat[i][col] == 1)
        {
            memset(visited, 0, sizeof(visited));
            solve(mat, visited, i, col, len, minlen);
            //if(minlen == C-1) break;                      //bcz time optimization
        }
    }
    
    if(minlen == INT_MAX)
        cout << "shortest path does not exist" << endl;
    else
        cout << "shortest path dist is " << minlen << endl;
}


int main()
{
    int mat[R][C] =
                    {
                        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
                        { 1, 0, 1, 1, 1, 1, 1, 1, 1, 1 },
                        { 1, 1, 1, 0, 1, 1, 1, 1, 1, 1 },
                        { 1, 1, 1, 1, 0, 1, 1, 1, 1, 1 },
                        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
                        { 1, 1, 1, 1, 1, 0, 1, 1, 1, 1 },
                        { 1, 0, 1, 1, 1, 1, 1, 1, 0, 1 },
                        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
                        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
                        { 0, 1, 1, 1, 1, 0, 1, 1, 1, 1 },
                        { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
                        { 1, 1, 1, 0, 1, 1, 1, 1, 1, 1 }
                    };
    
    int minlen = INT_MAX;
    int len = 0;
    
    findShortestPath(mat, minlen, len);
}
---------------------------------------------------------------------------------------------
Q11) Combinational Sum
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 								//gfg efficient sol
{
  public:

    vector<vector<int> > ans;
    void solve(int indx, vector<int> &A, int sum, vector<int> temp, int currS)		//helper fun
    {
        if(currS == sum)
        {
            ans.push_back(temp);
            return;
        }
        if(currS > sum) return;                         	//optional 
        
        for(int i=indx; i<A.size(); i++)
        {
            if(i>indx && A[i] == A[i-1]) continue;
            temp.push_back(A[i]);
            currS = currS + A[i];
            solve(i, A, sum, temp, currS);
            currS = currS - A[i];				//---> next line also backtracking
            temp.pop_back();
        }
    }
    vector<vector<int> > combinationSum(vector<int> &A, int B) 				//main fun
    {
        vector<int> temp;
        sort(A.begin(), A.end());
        solve(0, A, B, temp, 0);
        return ans;
    }
};
---------------------------------------------------------------------------------------------
Q12) Check whether K-th bit is set or not
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
    public:
    // Function to check if Kth bit is set or not.
    bool checkKthBit(int n, int k)
    {
        return (n >> k) & 1;
    }
};
---------------------------------------------------------------------------------------------
Q13) Find Maximum number possible by doing at-most K swaps
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg brute force
{
    public:
    void solve(string str, int k, string &mx)           //helper function
    {
        if(k == 0 ) return;                             //base condition
        
        int n = str.size();
        for(int i=0; i<n; i++)
        {
            for(int j=i+1; j<n; j++)
            {
                if(str[i] < str[j]) 
                {
                    swap(str[i], str[j]);
                    mx = max(str, mx);
                    solve(str, k-1, mx);
                    swap(str[i], str[j]);               //--->backtracking
                }
            }
        }
    }
    
    string findMaximumNum(string str, int k)
    {
       
       string max = str;
       solve(str, k, max);
       
       return max;
    }
};
---------------------------------------------------------------------------------------------
class Solution								//gfg efficient sol
{
    public:
    void solve(string &str, string &res, int k, int indx)               //helper fun
    {
        if(k == 0) return;
        char maxchar = str[indx];                   //finding maxchar
        for(int i=indx+1; i<str.size(); i++)
        {
            if(str[i] > maxchar) 
                maxchar = str[i];
        }
        if(maxchar != str[indx]) k--;               //if we found maxchar then only k--;
        
        for(int i=str.size()-1; i>=indx; i--)	    //rev. str traverse bcz of significance of digits
        {
            if(str[i] == maxchar) 
            {
                swap(str[indx], str[i]);
                res = max(res, str);
                solve(str, res, k, indx+1);
                swap(str[indx], str[i]);            //--->backtracking
            }
        }
        
    }
    
    string findMaximumNum(string str, int k)				//main fun
    {
        string res = str;
        
        solve(str, res, k, 0);
        
        return res;
    }
};
---------------------------------------------------------------------------------------------
Q14) Permutations of a given string
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
	public:
	    vector<string> ans;
	    unordered_map<string, int> mp;                      //for non repeating per.
	    void solve(string s, int l, int r)                  //helper fun
	    {
	        if(l==r) 
	        {
	            if(mp.find(s) == mp.end())
	            {
	                mp[s] = 1;
	                ans.push_back(s);
	            }
	        }
	
            for(int i=l; i<=r; i++)
	        {
	            swap(s[l], s[i]);
	            solve(s, l+1, r);
	            swap(s[l], s[i]);                          //--->backtracking
	        }
	    }
	    
	    vector<string> find_permutation(string s)	       //main fun
	    {
		 
		    solve(s,0, s.size()-1);
		    sort(ans.begin(), ans.end());
		    return ans;
	    }
};
---------------------------------------------------------------------------------------------
class Solution								//by using STL 
{
	public:
		vector<string> find_permutation(string s)
		{
		    sort(s.begin(), s.end());
		    vector<string> ans;
		    ans.push_back(s);
		    
		    while(next_permutation(s.begin(), s.end()))
		    {
		        ans.push_back(s);
		    }
		    return ans;
		}
};
---------------------------------------------------------------------------------------------
Q14)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

---------------------------------------------------------------------------------------------
Q14)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

---------------------------------------------------------------------------------------------
Q14)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

---------------------------------------------------------------------------------------------
Q14)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

---------------------------------------------------------------------------------------------
Q14)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

---------------------------------------------------------------------------------------------
