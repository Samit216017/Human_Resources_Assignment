                    		   ******Search & Sort******
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Q1) First and last occurrences of x 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vector<int> find(int arr[], int n , int x )				//gfg brute force
{
    vector<int> ans;
    int first = -1, last = -1;
    for(int i=0; i<n; i++)
    {
        if(x != arr[i]) continue;
        if(first == -1)
            first = i;
        last = i;
    }
    
    if(first == -1) ans.push_back(-1);
    else 
    {
        ans.push_back(first);
        ans.push_back(last);
    }
    
    return ans;
}
---------------------------------------------------------------------------------------------
vector<int> find(int a[], int n , int x )				//gfg brute force
{
    vector<int> ans;

    int first = lower_bound(a, a+n, x) - a;
    int last = upper_bound(a, a+n, x) - a - 1;
    
    if(first == n) ans.push_back(-1);
    else
    {
        ans.push_back(first);
        ans.push_back(last);
    }
    
    return ans;
}
---------------------------------------------------------------------------------------------
class Solution 							     //Leetcode efficient sol
{
public:
    int solve(vector<int> &a, int x, int tog)
    {
        int n = a.size();
        int low=0;
        int high=n-1;
        int ans=-1;
        while(low <= high)
        {
            int mid = (low + high) / 2;
            if(x < a[mid]) high = mid - 1;
            else if(x > a[mid]) low = mid + 1;
            else
            {
                ans = mid;
                if(tog == -1) high = mid + tog;
                else low = mid + tog;
            }
        }
        return ans;
    }
    
    vector<int> searchRange(vector<int> &a, int x) 
    {
        vector<int> ans;
        int n = a.size();
        int first = solve(a, x, -1);
        int last = solve(a, x, 1);

        if(first == -1) 
        {
            ans.push_back(-1);
            ans.push_back(-1);
        }
        else
        {
            ans.push_back(first);
            ans.push_back(last);
        }
        return ans;
    }
};
---------------------------------------------------------------------------------------------
Q2) Find a Fixed Point (Value equal to index) in a given array
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution
{
public:
	vector<int> valueEqualToIndex(int arr[], int n) 
	{
	    vector<int> ans;
	    for(int i=0; i<=n; i++)
	    {
	        if(arr[i] == i+1) ans.push_back(i+1);
	    }
	    return ans;
	}
};
---------------------------------------------------------------------------------------------
Q3)  Search in Rotated Sorted Array
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 							    //Leetcode efficient sol
{
public:
    int search(vector<int> &arr, int x) 
    {
        int low = 0;
        int high = arr.size() - 1;
        while(low <= high)
        {
            int mid = (low + high)/2;
            if(arr[mid] == x) return mid;
            
            if(arr[mid] >= arr[low]) 
            {
                if(arr[low] <= x && x <= arr[mid]) high = mid - 1;
                else low = mid + 1;
            }
            else 
            {
                if(arr[mid] <= x && x <= arr[high]) low = mid + 1;
                else high = mid - 1;
            }
        }
        return -1;
    }
};
---------------------------------------------------------------------------------------------
Q4) Count Squares
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 								//gfg efficient sol
{
  public:
    int countSquares(int N) 
    {
        int ans = 0;
        int i = 1;
        while(i*i < N)
        {
            ans++;
            i++;
        }
        return ans;
    }
};
---------------------------------------------------------------------------------------------
class Solution 
{
  public:
    int countSquares(int N) 
    {
        int ans = sqrt(N-1);
        return ans;
    }
};
---------------------------------------------------------------------------------------------
Q5) Find minimum and maximum element in an array		//repeated question
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
pair<long long, long long> getMinMax(long long arr[], int n) 
{
    long long mn = INT_MAX;
    long long mx = INT_MIN;
    for(int i=0; i<n; i++)
    {
        mn = min(mn, arr[i]);
        mx = max(mx, arr[i]);
    }
    pair<long long, long long> p;
    p.first = mn;
    p.second = mx;
    return p;
}
---------------------------------------------------------------------------------------------
#include <iostream>					//by struct brute force
using namespace std;
struct Pair
{
    int min; 
    int max;
};

Pair getMinMax(int arr[], int n)
{
    struct Pair minmax;
    if(n == 1)
    {
        minmax.min = arr[0];
        minmax.max = arr[0];
        return minmax;
    }
    
    if(arr[0] < arr[1])
    {
        minmax.min = arr[0];
        minmax.max = arr[1];
    }
    else
    {
        minmax.min = arr[1];
        minmax.max = arr[0];
    }
    
    for(int i=2; i<n; i++)
    {
        if(arr[i] < minmax.min) minmax.min = arr[i];
        if(arr[i] > minmax.max) minmax.max = arr[i];
    }
    return minmax;
}
int main()
{
    int arr[] = { 1000, 11, 445, 1, 330, 3000 };
    int n = 6;
    struct Pair minmax = getMinMax(arr, n);
      
    cout << "Minimum element is " << minmax.min << endl;
    cout << "Maximum element is " << minmax.max;

    return 0;
}
---------------------------------------------------------------------------------------------
#include <iostream>						//by struct efficient sol
using namespace std; 
struct Pair
{
    int min; 
    int max;
};

Pair getMinMax(int arr[], int n)
{
    struct Pair minmax;
    int i;
    if(n%2 == 1)
    {
        minmax.min = arr[0];
        minmax.max = arr[0];
        i = 1;
    }
    else                            //n is even
    {
        if(arr[0] < arr[1])
        {
            minmax.min = arr[0];
            minmax.max = arr[1];
        }
        else
        {
            minmax.min = arr[1];
            minmax.max = arr[0];
        }
        i = 2;
    }
    
    while(i < n-1)
    {
        if(arr[i] < arr[i+1])
        {
            if(arr[i] < minmax.min) minmax.min = arr[i];
            if(arr[i+1] > minmax.max) minmax.max = arr[i+1];
        }
        else
        {
            if(arr[i] > minmax.max) minmax.max = arr[i];
            if(arr[i+1] < minmax.min) minmax.min = arr[i+1];
        }
        i = i+2;
    }
    return minmax;
}

int main()
{
    int arr[] = { 1000, 11, 445, 1, 330, 3000 };
    int n = 6;
    struct Pair minmax = getMinMax(arr, n);
      
    cout << "Minimum element is " << minmax.min << endl;
    cout << "Maximum element is " << minmax.max;

    return 0;
}
---------------------------------------------------------------------------------------------
Q6) Find the repeating and the missing
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
public:
    int *findTwoElement(int *arr, int n) 
    {
        int *ans = new int[2];
        
        for(int i=0; i<n; i++)
        {
            if(arr[abs(arr[i]) - 1] < 0) 
                ans[0] = abs(arr[i]);
            else 
                arr[abs(arr[i]) - 1] = -arr[abs(arr[i]) - 1];
        }
        
        for(int i=0; i<n; i++)
        {
            if(arr[i] > 0)
            {
                ans[1] = i+1;
                break;
            }
        }
        return ans;
    }
};
---------------------------------------------------------------------------------------------
Q7) Mejority element 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 								//Leetcode sol
{
public:
    int majorityElement(vector<int>& arr) 
    {
        int n = arr.size();
        unordered_map<int, int> mp;
        int ans;
        
        for(int i=0; i<n; i++)
            mp[arr[i]]++;
        
        for(auto x : mp)
        {
            if(x.second > n/2) ans = x.first;
        }
        return ans;
    }
};
---------------------------------------------------------------------------------------------
class Solution{								//gfg brute force
  public:
    int majorityElement(int arr[], int n)
    {
        unordered_map<int, int> mp;
    
        for(int i=0; i<n; i++)
            mp[arr[i]]++;
        
        for(auto x : mp)
        {
            if(x.second > n/2) return x.first;
        }
   
        return -1;
        
    }
};
---------------------------------------------------------------------------------------------
class Solution								//gfg efficient sol
{
  public:
    int findCandidate(int a[], int size) 			//hlper-1
    { 
        int maj_index = 0, count = 1; 
        
        for (int i = 1; i < size; i++) 
        { 
            if(a[maj_index] == a[i]) count++; 
            else count--;
                 
            if (count == 0) 
            { 
                maj_index = i; 
                count = 1; 
            } 
        } 
        return a[maj_index]; 
    }
    
    bool isMajority(int a[], int size, int cand) 		//helper-2
    { 
        int count = 0; 
        for(int i = 0; i < size; i++) 
            if(a[i] == cand) count++; 
              
        if(count > size/2) return 1; 
        else return 0; 
    } 
    
    int majorityElement(int a[], int size)			//main fun
    {
        /* Find the candidate for Majority*/
       int cand = findCandidate(a, size); 
      
       /* Print the candidate if it is Majority*/
        if(isMajority(a, size, cand)) return cand;
        else return -1;
    }
};
---------------------------------------------------------------------------------------------
Q8) Searching in an array where adjacent differ by at most k
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
int search(int arr[], int n, int x, int k)				//gfg brute force
{
    int i=0;
    while(i<n)
    {
        if(arr[i] == x) return i;
        i++;
    }
    return -1;
}  
---------------------------------------------------------------------------------------------
int search(int arr[], int n, int x, int k)				//gfg efficient sol
{
    int i=0;
    while(i<n)
    {
        if(arr[i] == x) return i;
        
        i = i + max(1, abs(arr[i] - x)/k);
    }
    return -1;
}  
---------------------------------------------------------------------------------------------
Q9) Find Pair Given Difference 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""				
bool findPair(int arr[], int size, int x)		     //gfg brute force-tc-n^2, sc-1
{
    int ans = 0;
    for(int i=0; i<size; i++)
    {
        int a = arr[i] + x;
        for(int j=0; j<size; j++)
        {
            if(a == arr[j]) ans = 1;
        }
    }
    return ans;
}
---------------------------------------------------------------------------------------------
bool findPair(int arr[], int size, int x)				//tc-n & sc-n
{
    int ans = 0;
    unordered_map<int, int> mp;
    for(int i=0; i<size; i++)
        mp[arr[i]]++;
        
    for(int i=0; i<size; i++)
    {
        int a = arr[i] + x;
        if(mp[a]) 
        {
            ans = true;
            break;
        }
    }
    return ans;
}
---------------------------------------------------------------------------------------------
bool findPair(int arr[], int size, int n)				//gfg efficient sol
{
    sort(arr,arr+size);
    int i = 0;  
    int j = 1;
 
    while(i<size && j<size)
    {
        if(i != j && arr[j]-arr[i] == n) return true;
        
        else if(arr[j]-arr[i] < n) j++;
        
        else i++;
    }
    return false;
}
---------------------------------------------------------------------------------------------
Q10) Find All Four Sum Numbers
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
    public:
    vector<vector<int> > fourSum(vector<int> &arr, int x) 
    {
        int n = arr.size();
        sort(arr.begin(), arr.end());
        set<vector<int>> curr_ans;
        vector<vector<int>> ans = {};

        for(int i=0; i<n-3; i++)
        {
            for(int j=i+1; j<n-2; j++)
            {
                int k = j+1, l=n-1;
                while(k<l)
                {
                    if((arr[i] + arr[j] + arr[k] + arr[l]) == x)
                    {
                        curr_ans.insert({arr[i], arr[j], arr[k], arr[l]});
                        k++;
                        l--;
                    }
                    else if((arr[i]+arr[j]+arr[k]+arr[l])<x) k++;
                    else l--;
                }
            }
        }
        
        for(auto x:curr_ans)
        {
            ans.push_back(x);
        }
        sort(ans.begin(), ans.end());
        return ans;
    }
};
---------------------------------------------------------------------------------------------
Q11) Max Sum without Adjacents
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg brute force
{
    public:
    int dp[10001];
    int solve(int arr[], int i)
    {
        if(i <= -1) return 0;
        if(dp[i] != -1) return dp[i];
        
        int op1 = arr[i] + solve(arr, i-2);
        int op2 = solve(arr, i-1);
        return max(op1, op2);
    }
    
    int FindMaxSum(int arr[], int n)
    {
        memset(dp, -1, sizeof(dp));
        return solve(arr, n-1);
    }
};
---------------------------------------------------------------------------------------------
class Solution								//gfg efficient sol
{
    public:
    
    int FindMaxSum(int arr[], int n)
    {
        int in = arr[0];
        int ex = 0;
        int ex_n;
        for(int i=1; i<n; i++)
        {
            ex_n = max(in, ex);
            
            in = ex + arr[i];
            ex = ex_n;
        }
        return max(in, ex);
    }
};
---------------------------------------------------------------------------------------------
Q12) Count triplets with sum smaller than X 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg brute force
{	
	public:
	long long countTriplets(long long arr[], int n, long long sum)
	{
	    int c = 0;
	    for(int i=0; i<n-2; i++)
	    {
	        for(int j=0; j<n-1; j++)
	        {
	            for(int k=0; k<n; k++)
	            {
	                if(arr[i] + arr[j] + arr[k] < sum && i<j && j<k)
	                    c++;
	            }
	        }
	    }
	    return c;
	}
};
---------------------------------------------------------------------------------------------
class Solution								//gfg efficient sol
{	
	public:
	long long countTriplets(long long arr[], int n, long long sum)
	{
	    int c = 0;
	    sort(arr, arr+n);
	    for(int i=0; i<n-2; i++)
	    {
	        int j = i+1, k = n-1;
	        while(j < k)
	        {
	            if(arr[i] + arr[j] + arr[k] < sum)
	            {
	                c = c + k - j;
	                j++;
	            }
	            else k--;
	        }
	    }
	    return c;
	}
};
---------------------------------------------------------------------------------------------
Q13) Merge Without Extra Space					//Repeated question
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
public:
	void merge(int arr1[], int arr2[], int n, int m) 
	{
	    int i=n-1, j=0;
	    while(i >= 0 && j < m)
	    {
	        if(arr1[i] >= arr2[j])
	        {
	            swap(arr1[i], arr2[j]);
	            i--;
	            j++;
	        }
	        else
	        {
	            break;
	        }
	    }
	    
	    sort(arr1, arr1+n);
	    sort(arr2, arr2+m);
	}
};
---------------------------------------------------------------------------------------------
Q14) Zero Sum Subarrays
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
    public:
    //Function to count subarrays with sum equal to 0.
    ll findSubarray(vector<ll> arr, int n ) 
    {
        unordered_map<int, int> mp;
        mp[0] = 1;
        int c = 0;
        int sum = 0;
        for(int i=0; i<n; i++)
        {
            sum = sum + arr[i];
            if(mp.find(sum) != mp.end()) 
            {
                c = c + mp[sum];
            }
            mp[sum]++;
        }
        return c;
    }
};
---------------------------------------------------------------------------------------------
Q15) Product array puzzle
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
  public:
    vector<long long int> productExceptSelf(vector<long long int>& arr, int n) 
    {
        //if(n == 1) return {1};
        long long int pro = 1;
        int zeroC = 0;
        for(int i=0; i<n; i++)
        {
            if(arr[i] != 0) pro = pro * arr[i];
            else zeroC++;
        }
        
        vector<long long int> ans;
        for(int i=0; i<n; i++)
        {
            if(zeroC == 0)
                ans.push_back(pro / arr[i]);
                
            else
            {
                if(arr[i] != 0) ans.push_back(0);
                else 
                {
                    if(zeroC > 1) ans.push_back(0);
                    else ans.push_back(pro);
                }
            }
        }
        return ans;
    }
};

i/p and o/p:-
5
4 0 5 6 8
0 960 0 0 0 

5
1 0 2 0 5
0 0 0 0 0 

5
4 5 6 2 8
480 384 320 960 240 

---------------------------------------------------------------------------------------------
Q16) Sort by Set Bit Count
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
    public:
    int solve(int n)                                    //helper fun              
    {
        int c = 0;
        while(n)
        {
            if(n&1 == 1) c++;
            n = n>>1;
        }
        return c;
    }
    
    void sortBySetBitCount(int arr[], int n)            //main fun
    {
        vector<vector<int>> count(32);
        int c;
        for(int i=0; i<n; i++)
        {
            c = solve(arr[i]);
            count[c].push_back(arr[i]);
        }
        
        int j = 0;
        for(int i=31; i>=0; i--)
        {
            vector<int> v = count[i];
            for(int k=0; k<v.size(); k++)
            {
                arr[j] = v[k];
                j++;
            }
        }
    }
};
---------------------------------------------------------------------------------------------
Q17) Function to find the minimum number of swaps required to sort the array.
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 								//gfg efficient sol
{
    public: 
	int minSwaps(vector<int>&arr)
	{
	    vector<pair<int, int>> v;
	    for(int i=0; i<arr.size(); i++)
	    {
	        v.push_back({arr[i], i});
	    }
	    
	    sort(v.begin(), v.end());
	    
	    int ans = 0;
	    for(int i=0; i<arr.size(); i++)
	    {
	        if(v[i].second != i)
	        {
	            ans++;
	            swap(v[i], v[v[i].second]);
	            i--;
	        }
	    }
	    return ans;
	}
};
---------------------------------------------------------------------------------------------
Q18) Bishu and Soldiers
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include<bits/stdc++.h>						 //Hackerearth efficient sol
using namespace std;

int main()
{
	int n;
	cin >> n;
	int arr[n];
	for(int i=0; i<n; i++)
		cin >> arr[i];

	int q;
	cin >> q;

	sort(arr, arr+n);

	int pre[n+1];
	pre[0] = 0;
	for(int i=1; i<n+1; i++)
		pre[i] = pre[i-1] + arr[i-1];

	while(q--)
	{
		int x;
		cin >> x;
		int idx = upper_bound(arr, arr+n, x) - arr;
		cout << idx << " " << pre[idx] << endl;
	}
}
---------------------------------------------------------------------------------------------
Q19) Kth smallest number again
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>
using namespace std;

int main() 
{
	int t;
	cin >> t;    
	while(t--)
	{
		long long int n, q;
		cin >> n >> q;
		vector<pair<long long int, long long int>> v;
		for(long long int i=0; i<n; i++)
		{
			long long int x, y;
			cin >> x >> y;
			v.push_back({x, y});
		}
		sort(v.begin(), v.end());				  		//sorting -> 1

		long long int idx = 0;							//merge overlapped intervals -> 2
		for(long long int i=1; i<v.size(); i++)
		{
			if(v[idx].second >= v[i].first)
				v[idx].second = max(v[idx].second, v[i].second);
			else
			{
				idx++;
				v[idx] = v[i];
			}
		}

		while(q--)								//searching -> 3
		{
			long long int k;
			cin >> k;
			long long int ans = -1;
			for(long long int i=0; i<=idx; i++)
			{
				if((v[i].second - v[i].first + 1) >= k)
				{
					ans = v[i].first + k - 1;
					break;
				}
				else
				{
					k = k - (v[i].second - v[i].first + 1);
				}
			}
			cout << ans << endl;
		}
	}
}
---------------------------------------------------------------------------------------------
Q20) Minimum element in a sorted and rotated array 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
public:
    int findMin(int arr[], int n)
    {
        if(arr[0] <= arr[n-1]) return arr[0];
        int low = 0;
        int high = n-1;
        while(low <= high)
        {
            int mid = (low + high)/2;
            if(arr[mid-1] > arr[mid])
            {
                return arr[mid];
            }
            else if(arr[mid] >= arr[0])
            {
                low = mid + 1;
            }
            else
            {
                if(arr[mid-1] > arr[mid]) return arr[mid];
                high = mid - 1;
            }
        }
    }
};
---------------------------------------------------------------------------------------------
Q21) K-th element of two sorted Arrays
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg brute force
{
    public:
    int kthElement(int arr1[], int arr2[], int n, int m, int k)
    {
        priority_queue<int> pq;
        for(int i=0; i<n; i++)
        {
            pq.push(arr1[i]);
            if(pq.size() > k) pq.pop();
        }
        
        for(int i=0; i<m; i++)
        {
            pq.push(arr2[i]);
            if(pq.size() > k) pq.pop();
        }
        
        return pq.top();
    }
};
---------------------------------------------------------------------------------------------
class Solution								//gfg efficient sol
{
    public:
    int kthElement(int arr1[], int arr2[], int n, int m, int k)
    {
        if(n > m)
            return kthElement(arr2, arr1, m, n, k);
        
        int low = max(0, k-m);
        int high = min(k, n);
        while(low <= high)
        {
            int cut1 = (low + high) >> 1;           		//more efficient than (l+h)/2
            int cut2 = k - cut1;
            
            int l1 = cut1==0 ? INT_MIN : arr1[cut1 - 1];
            int l2 = cut2==0 ? INT_MIN : arr2[cut2 - 1];
            int r1 = cut1==n ? INT_MAX : arr1[cut1];
            int r2 = cut2==m ? INT_MAX : arr2[cut2];
            
            if(l1 <= r2 && l2 <= r1) return max(l1, l2);
            
            else if(l1 > r2) high = cut1 - 1;
            
            else low = cut1 + 1;
        }
        return 1;
    }
};
---------------------------------------------------------------------------------------------
Q22) Aggressive cows
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>						//spoj efficient sol
using namespace std;

int main() 
{
	int t;
	cin >> t;
	while(t--)
	{
		int n, c;
		cin >> n >> c;
		int arr[n];
		for(int i=0; i<n; i++)
			cin >> arr[i];
			
		sort(arr, arr+n);
		
		int low = 1;
		int high = 1e9;
		int ans = 0;
		while(low <= high)
		{
			int mid = (low + high) >> 1;
			int cow = 1;
			int prev = arr[0];
			for(int i=1; i<n; i++)
			{
				if(arr[i] - prev >= mid)
				{
					cow++;
					prev = arr[i];
					if(c == cow) break;
				}
			}
			
			if(c == cow)
			{
				ans = mid;
				low = mid+1;
			}
			else
			{
				high = mid - 1;
			}
		}
		cout << ans << endl;
	}
	return 0;
}
---------------------------------------------------------------------------------------------
Q23) Allocate minimum number of pages	//must read article for Question
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 								//gfg efficient sol
{
    public:
    //Function to find minimum number of pages.
    bool solve(int arr[], int n, int mid, int m)            //helper fun
    {
        int sum = 0;
        int stu = 1;
        for(int i=0; i<n; i++)
        {
            if(arr[i] > mid) return false;
            if(sum + arr[i] > mid)
            {
                stu++;
                sum = arr[i];
                if(stu > m) return false;
            }
            else sum = sum + arr[i];
        }
        return true;
    }
    
    int findPages(int arr[], int n, int m)                  //main fun
    {
        int low = 0;
        int sum = 0;
        for(int i=0; i<n; i++) sum = sum + arr[i];
        int high = sum;
        int ans = 0;
        
        while(low <= high)
        {
            int mid = (low + high) >> 1;
            if(solve(arr, n, mid, m) == true)
            {
                ans = mid;
                high = mid - 1;
            }
            else low = mid + 1;
        }
        return ans;
    }
};
---------------------------------------------------------------------------------------------
Q24) Eko spoj problem
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include<bits/stdc++.h>							//spoj efficient sol
using namespace std;

bool solve(int arr[], int n, int m, int mid)			//helper fun
{
	int sum = 0;
	for(int i=0; i<n; i++)
	{
		if(arr[i] > mid)
			sum = sum + arr[i] - mid;
		if(sum >= m) return true;
	}	
	return false;
}
		
int main()
{
	int n, m;
	cin >> n >> m;
	int arr[n];
	for(int i=0; i<n; i++)
		cin >> arr[i];
	//sort(arr, arr+n);
	int low = 0;
	int high = *max_element(arr, arr+n);
	int ans = 0;
	while(low <= high)
	{
		int mid = (low + high) >> 1;
		if(solve(arr, n, m, mid))
		{
			ans = mid;
			low = mid + 1;
		}
		else high = mid - 1;
	}
	cout << ans << endl;
	return 0;
}
---------------------------------------------------------------------------------------------
Q25) Maximum Profit in Job Scheduling
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 							     //Leetcode efficient sol
{
public:
    static bool comp(vector<int> a, vector<int> b)
    {
        return a[1] < b[1];
    }
    
    int jobScheduling(vector<int>& start, vector<int>& end, vector<int>& profit) 
    {
        int n = start.size();
        vector<vector<int>> v(n);
        for(int i=0; i<n; i++)
        {
            int x = start[i];
            int y = end[i];
            int w = profit[i];
            v[i] = {x, y, w};
        }
        sort(v.begin(), v.end(), comp);
        int dp[n];
        dp[0] = v[0][2];
        
        for(int i=1; i<n; i++)
        {
            int inc = v[i][2];
            int last = -1;
            int low = 0;
            int high = i-1;
            while(low <= high)
            {
                int mid = (low + high) >> 1;
                if(v[mid][1] <= v[i][0])
                {
                    last = mid;
                    low = mid + 1;
                }
                else high = mid - 1;
            }
            if(last != -1) inc = inc + dp[last];
            int exc = dp[i-1];
            dp[i] = max(inc, exc);
        }
        return dp[n-1];  
    }
};
---------------------------------------------------------------------------------------------
Q26) Missing Number in AP
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
public:
    int inSequence(int A, int B, int C)
    {
        if(C == 0) 
        {
            if(A==B) return 1;
            else return 0;
        }
        else
        {
            if((B-A)/C < 0) return 0;
            else
            {
                if((B-A)%C == 0) return 1;
                else return 0;
            }
        }
    }
};
---------------------------------------------------------------------------------------------
Q27) Smallest number with atleastn trailing zeroes infactorial
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
    public:
        bool solve(int mid, int n)              //helper fun
        {
            int c = 0;
            int f = 5;
            while(f <= mid)
            {
                c = c + mid/f;
                f = f*5;
            }
            return c >= n;
        }
        
        int findNum(int n)                      //main fun
        {
            if(n == 1) return 5;
            int low = 0;
            int high = 5*n;
            while(low <= high)
            {
                int mid = (low + high) >> 1;
                if(solve(mid, n)) high = mid - 1;
                else low = mid + 1;
            }
            return low;
        }
};
---------------------------------------------------------------------------------------------
Q28) Roti-paratha problem
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>						//spoj efficient sol
using namespace std;

bool solve(int arr[], int n, int para, int mid)			//helper fun
{
	int t = 0;
	int nop = 0;						//nop-->#of paratha made in t time
	for(int i=0; i<n; i++)
	{
		t = arr[i];
		int j = 2;
		while(t <= mid)
		{
			nop++;
			t = t + (arr[i] * j);
			j++;
		}
		if(nop >= para) return true;
	}
	return false;
}

int main() 
{
	int t;
	cin >> t;
	while(t--)
	{
		int para;
		cin >> para;
		int n;
		cin >> n;
		int arr[n];
		for(int i=0; i<n; i++) cin >> arr[i];
		int low = 0;
		int high = 1e9;
		int ans = 0;
		while(low <= high)
		{
			int mid = (low + high) >> 1;
			if(solve(arr, n, para, mid) == true) 
			{
				ans = mid;
				high = mid - 1;
			}
			else low = mid + 1;
		}
		cout << ans << endl;
	}
	return 0;
}
---------------------------------------------------------------------------------------------
Q29) The Double HeLiX
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>						//spoj efficient sol
using namespace std;

int main() 
{
	while(true)
	{
		int n, m;
		cin >> n;
		if(n == 0) break;
		else
		{
			int arr1[n];
			for(int i=0; i<n; i++) cin >> arr1[i];
			cin >> m;
			int arr2[m];
			for(int i=0; i<m; i++) cin >> arr2[i];
			
			int s1 = 0, s2 = 0;
			int i = 0, j = 0;
			int ans = 0;
			while(i < n && j < m)
			{
				if(arr1[i] < arr2[j]) s1 = s1 + arr1[i++];
				else if(arr1[i] > arr2[j]) s2 = s2 + arr2[j++];
				else
				{
					ans = ans + max(s1, s2) + arr1[i];
					s1 = s2 = 0;
					i++;
					j++;
				}
			}
			
			while(i < n) s1 = s1 + arr1[i++];
			while(j < m) s2 = s2 + arr2[j++];
			ans = ans + max(s1, s2);
			cout << ans << endl;
		}
	}
	return 0;
}
---------------------------------------------------------------------------------------------
Q30) Inplace merge saort
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include<bits/stdc++.h>
using namespace std;

void InplaceMerge(int arr[], int low, int high)
{
    int gap = ceil((high-low+1)/2);
    while(gap >= 1)
    {
        for(int i=low; i+gap<=high; i++)
        {
            if(arr[i] > arr[i+gap])
            {
                swap(arr[i], arr[i+gap]);
            }
        }
        gap = ceil(gap/2);
    }
}

void mergeSort(int arr[], int low, int high)
{
    if(low==high) return;
    int mid = (low+high)/2;
    mergeSort(arr, low, mid);
    mergeSort(arr, mid+1, high);
   
    InplaceMerge(arr,low, high);
}

int main()
{
    int nums[] = { 12, 11, 13, 5, 6, 7 };
    mergeSort(nums, 0,5);
    for(int i=0;i<6;i++)
    {
        cout << nums[i] << " ";
    }
    return 0;
}
---------------------------------------------------------------------------------------------

Q27)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

---------------------------------------------------------------------------------------------

Q27)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

---------------------------------------------------------------------------------------------

Q27)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

---------------------------------------------------------------------------------------------