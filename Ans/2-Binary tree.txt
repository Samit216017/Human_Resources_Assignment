Q1) Level order traversal
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
struct Node
{
    int data;
    struct Node* left;
    struct Node* right;
    
    Node(int x)
    {
        data = x;
        left = right = NULL;
    }
};
   
class Solution
{
    public:
    //Function to return the level order traversal of a tree.
    vector<int> levelOrder(Node* root)
    {
      vector<int> ans;
      queue<Node*> q;
      if(!root) return ans;
      
      q.push(root);
      while(!q.empty())
      {
          Node *temp = q.front();
          q.pop();
          ans.push_back(temp->data);
          if(temp->left) q.push(temp->left);
          if(temp->right) q.push(temp->right);
      }
      return ans;
    }
};
--------------------------------------------------------------------------------------------
Q2) reverse level order traversal
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vector<int> reverseLevelOrder(Node *root)
{
    vector<int> res;
    if(!root)return res;
    queue<Node*> q;
    q.push(root);
    
    while(!q.empty())
    {
        Node *t = q.front();
        res.push_back(t->data);
        if(t->right) q.push(t->right);
        if(t->left) q.push(t->left);
        q.pop();
    }
    reverse(res.begin(), res.end());
    return res;
}
--------------------------------------------------------------------------------------------
Q3) height of binary tree
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
int height(struct Node* root)
{
    if(!root) return 0;
    int x = height(root->left);
    int y = height(root->right);
    
    if(x >= y)return x+1;
    return y+1;
}
--------------------------------------------------------------------------------------------
Q4) diameter of a binary tree
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 					//gfg practice:- # of nodes on longest path
{
  public:
  int ma;
  
  int fun(Node *root)
  {
      if(!root)return 0;
      int x = fun(root->left);
      int y = fun(root->right);
      ma = max(ma, x+y+1);
      return max(x,y) + 1;
  }
    
  int diameter(Node* root) 		// Function to return the diameter of a Binary Tree
  {
        ma = INT_MIN;
        fun(root);
        return ma;
  }
};
--------------------------------------------------------------------------------------------
class Solution 					     //Leetcode:- # of edges on longest path
{
public:
    int ans;
    int solve(TreeNode *root)
    {
        if(!root) return 0;
        int l = solve(root->left);
        int r = solve(root->right);
        
        ans = max(ans, l+r+1);
        return max(l, r) + 1;
    }
    
    int diameterOfBinaryTree(TreeNode* root) 
    {
        ans = INT_MIN;
        solve(root);
        
        return ans-1;        
    }
};
--------------------------------------------------------------------------------------------
Q4-II) Binary Tree Maximum Path Sum
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 							//Leetcode efficient sol
{
public:
    int ans;
    int solve(TreeNode *root)
    {
        if(!root) return 0;
        int l = solve(root->left);
        int r = solve(root->right);
        
        l = max(l, 0);
        r = max(r, 0);
        ans = max(ans, l + r + root->val);
        return max(l, r) + root->val;
    }
    
    int maxPathSum(TreeNode* root) 
    {
        ans = INT_MIN;
        solve(root);
        return ans;       
    }
};
--------------------------------------------------------------------------------------------
Q5) mirror tree
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
void mirror(Node* root) 
{
    if(!root) return;
    
    mirror(root->left);
    mirror(root->right);
    swap(root->left, root->right);
}
--------------------------------------------------------------------------------------------
Q6) inorder traversal of binary tree
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vector<int> inorderTraversal(TreeNode* root) 		//iterative method
{
        vector<int> v;
        if(!root) return v;
        stack<TreeNode*> st;
        TreeNode *curr = root;
        
        while(true)
        {
            if(curr)
            {
                st.push(curr);
                curr = curr->left;
            }
            else
            {
                if(st.empty() == true)break;
                curr = st.top();
                v.push_back(curr->val);
                st.pop();
                curr = curr->right;
            }
        }
        return v;
}
--------------------------------------------------------------------------
void func(Node *root, vector<int> &v)		//recursive method by vector
{
    if(root)
    {
        func(root->left, v);
        v.push_back(root->data);
        func(root->right, v);
    }
}

vector<int> inOrder(Node* root) 
{
    vector<int> v;
    func(root, v);
    return v;
}
--------------------------------------------------------------------------
void inorder(Node *root) 				//recursive method
{
   if (root != NULL) 
   {
      inorder(root->left);
      cout << root->data << " ";
      inorder(root->right);
   }
}
--------------------------------------------------------------------------------------------
Q7) preorder traversal of binary tree
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vector<int> preorderTraversal(TreeNode* root) 		//iterative method
{
        vector<int> v;
        if(!root) return v;
        stack<TreeNode*> st;
        st.push(root);
        
        while(st.empty() == false)
        {
            root = st.top();
            v.push_back(root->val);
            st.pop();
            
            if(root->right) st.push(root->right);
            if(root->left) st.push(root->left);
        }
        return v;
}
--------------------------------------------------------------------------
void func(Node *root, vector<int> &v)		//recursive method by vector
{
    if(root)
    {
        v.push_back(root->data);
        func(root->left, v);
        func(root->right, v);
    }
}

vector <int> preOrder(Node* root)
{
  vector<int> v;
  func(root, v);
  return v;
}
--------------------------------------------------------------------------
void preorder(Node *root) 				//recursive method
{
   if (root != NULL) 
   {
      cout << root->data << " ";
      preorder(root->left);
      preorder(root->right);
   }
}
--------------------------------------------------------------------------------------------
Q8) postorder traversal of binary tree
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <iostream>					//iterative method(2-stack)
#include <stack>
using namespace std;

struct Node
{
    int data;
    Node *left, *right;
    Node(int data)
    {
        this->data = data;
        this->left = this->right = NULL;
    }
};
 
void postorderIterative(Node* root)
{
    if (!root) return;

    stack<Node*> st;
    st.push(root);
    stack<int> op;

    while (!st.empty())
    {
        Node* curr = st.top();
        st.pop();
        op.push(curr->data);
 
        if (curr->left) st.push(curr->left);
        if (curr->right) st.push(curr->right);
    }
 
    while (!op.empty())
    {
        cout << op.top() << " ";
        op.pop();
    }
}
 
int main()
{
    /* Construct the following tree
               1
             /   \
            /     \
           2       3
          /      /   \
         /      /     \
        4      5       6
              / \
             /   \
            7     8
    */
 
    Node* root = new Node(1);
    root->left = new Node(2);
    root->right = new Node(3);
    root->left->left = new Node(4);
    root->right->left = new Node(5);
    root->right->right = new Node(6);
    root->right->left->left = new Node(7);
    root->right->left->right = new Node(8);
 
    postorderIterative(root);
 
    return 0;
}
--------------------------------------------------------------------------------------
vector<int> postorderTraversal(TreeNode* root)    	   //iterative method(1-stack)
{
        vector<int> v;
        if(!root) return v;
        stack<TreeNode*> st;
        TreeNode *curr = root, *prev = NULL;
        
        while(curr || !st.empty())
        {
            if(curr)
            {
                st.push(curr);
                curr = curr->left;
            }
            else
            {
                curr = st.top();
                if(curr->right == NULL || curr->right == prev)
                {
                    v.push_back(curr->val);
                    st.pop();
                    prev = curr;
                    curr = NULL;
                }
                else
                {
                    curr = curr->right;
                }
            }
        }
        return v;
}
--------------------------------------------------------------------------
void func(Node *root, vector<int> &v)		//recursive method by vector
{
    if(root)
    {
        func(root->left, v);
        func(root->right, v);
        v.push_back(root->data);
    }
}

vector <int> postOrder(Node* root)
{
  vector<int> v;
  func(root, v);
  return v;
}
--------------------------------------------------------------------------
void postorder(Node *root) 				//recursive method
{
   if (root != NULL) 
   {
      postorder(root->left);
      postorder(root->right);
      cout << root->data << " ";
   }
}
----------------------------------------------------------------------------------------------
Q9) left view of binary tree
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vector<int> leftView(Node *root)
{
   vector<int> v;
   if(!root) return v;
   queue<Node*> q;
   q.push(root);
   
   while(!q.empty())
   {
       int siz = q.size();
       v.push_back(q.front()->data);
       
       while(siz--)
       {
           Node *t = q.front();
           q.pop();
           if(t->left) q.push(t->left);
           if(t->right) q.push(t->right);
       }
   }
   return v;
}
----------------------------------------------------------------------------------------------
Q10) right view of binary tree
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vector<int> rightView(Node *root)
{
       vector<int> v;
       if(!root) return v;
       queue<Node*> q;
       q.push(root);
       
       while(!q.empty())
       {
           int siz = q.size();
           Node *t;
           
           while(siz)
           {
               t = q.front();
               q.pop();
               if(t->left) q.push(t->left);
               if(t->right) q.push(t->right);
               siz--;
           }
           v.push_back(t->data);
       }
       return v;
}
----------------------------------------------------------------------------------------------
Q11) top view of binary tree
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vector<int> topView(Node *root)
{
        vector<int> v;
        if(!root) return v;
        map<int, int> m;
        queue<pair<Node*, int>> q;
        q.push({root, 0});
        
        while(!q.empty())
        {
            Node *t = q.front().first;
            int h = q.front().second;
            q.pop();
            
            if(!m[h]) m[h] = t->data;
            if(t->left) q.push({t->left, h-1});
            if(t->right) q.push({t->right, h+1});
        }
        
        for(auto x:m) 
        {
            v.push_back(x.second);
        }
        
        return v;
}
----------------------------------------------------------------------------------------------
Q12) bottom view of binary tree
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vector <int> bottomView(Node *root) 
{
        vector<int> v;
        if(!root) return v;
        map<int, int> m;
        queue<pair<Node*, int>> q;
        q.push({root, 0});
        
        while(!q.empty())
        {
            Node *t = q.front().first;
            int h = q.front().second;
            q.pop();
            
            m[h] = t->data;
            if(t->left) q.push({t->left, h-1});
            if(t->right) q.push({t->right, h+1});
        }
        
        for(auto x:m)
        {
            v.push_back(x.second);
        }
        
        return v;
}
----------------------------------------------------------------------------------------------
Q13) zigzag tre traversal
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vector<int> zigZagTraversal(Node* root)
{
    	vector<int> v;
    	if(!root) return v;
    	queue<Node*> q;
    	q.push(root);
    	int f = 1;
    	
    	while(!q.empty())
    	{
    	    vector<int> temp;
    	    int siz = q.size();
    	    
    	    while(siz)
    	    {
    	        Node *t = q.front();
    	        q.pop();
    	        temp.push_back(t->data);
    	        
    	        if(t->left) q.push(t->left);
    	        if(t->right) q.push(t->right);
    	        siz--;
    	    }
    	    
    	    if(f%2 == 0) reverse(temp.begin(), temp.end());
    	    for(int i=0; i<temp.size(); i++) v.push_back(temp[i]);
    	    f = !f;
    	}
    	return v;
}
----------------------------------------------------------------------------------------------
Q14) check for balanced tree
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
public:
int f = 1;
    
int solve(Node *root)
{
        if(!root) return 0;
        int l = solve(root->left);
        int r = solve(root->right);
        
        if(abs(l-r) > 1) f = 0;
        
        return max(l,r) + 1;
}
    
bool isBalanced(Node *root)
{
        f = 1;
        solve(root);
        return f;
}
----------------------------------------------------------------------------------------------
Q15) diagonal traversal of binary tree
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vector<int> diagonal(Node *root)
{
   vector<int> v;
   if(!root) return v;
   queue<Node*> q;
   q.push(root);
   
   while(!q.empty())
   {
       Node *t = q.front();
       q.pop();
       
       while(t)
       {
           if(t->left) q.push(t->left);
           v.push_back(t->data);
           t = t->right;
       }
   }
   return v;
}
----------------------------------------------------------------------------------------------
Q16) boundary traversal of binary tree
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
public:
void lefttree(Node *root, vector<int> &v)		//lefttree
{
    if(!root) return;
    
    if(root->left)
    {
        v.push_back(root->data);
        lefttree(root->left, v);
    }
    else if(root->right)
    {
        v.push_back(root->data);
        lefttree(root->right, v);
    }
}

void leaf(Node *root, vector<int> &v)			//leaf
{
    if(!root) return;
    leaf(root->left, v);
    if(!root->left && !root->right)
        v.push_back(root->data);
    leaf(root->right, v);
}

void righttree(Node *root, vector<int> &v)		//righttree
{
    if(!root) return;
    
    if(root->right)
    {
        righttree(root->right, v);
        v.push_back(root->data);
    }
    else if(root->left)
    {
        righttree(root->left, v);
        v.push_back(root->data);
    }
}


vector <int> boundary(Node *root)			//boundary
{
        vector<int> v;
        v.push_back(root->data);
        lefttree(root->left, v);
        if(root->left || root->right)
        {
            leaf(root, v);
            
        }
        righttree(root->right, v);
        
        return v;
}
----------------------------------------------------------------------------------------------
Q17-not) construct binary tree from string
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>
using namespace std;

struct Node 
{
	int data;
	Node *left, *right;
};

Node* newNode(int data)
{
	Node* node = (Node*)malloc(sizeof(Node));
	node->data = data;
	node->left = node->right = NULL;
	return (node);
}

void preOrder(Node *node)
{
	if(node == NULL) return;
	cout << node->data << " ";
	preOrder(node->left);
	preOrder(node->right);
}

// function to return the index of close parenthesis
int findIndex(string str, int si, int ei)
{
	if (si > ei) return -1;
    stack<char> s;

	for (int i=si; i<=ei; i++) 
	{
		if(str[i] == '(') s.push(str[i]);   // if open parenthesis, push it

		else if(str[i] == ')')              // if close parenthesis 
		{
			if (s.top() == '(') 
			{
				s.pop();
				if (s.empty()) return i;
			}
		}
	}
	// if not found return -1
	return -1;
}

Node* treeFromString(string str, int si, int ei)
{
	if(si > ei) return NULL;

	Node* root = newNode(str[si] - '0');
	int index = -1;

	// if next char is '(' find the index of its complement ')'
	if (si+1 <= ei && str[si+1] == '(')
		index = findIndex(str, si+1, ei);

	// if index found
	if (index != -1) 
	{
		root->left = treeFromString(str, si + 2, index-1);
		root->right = treeFromString(str, index+2, ei-1);
	}
	return root;
}

int main()
{
	string str = "4(2(3)(1))(6(5))";
	Node* root = treeFromString(str, 0, str.length()-1);
	preOrder(root);
}
----------------------------------------------------------------------------------------------
Q18) binary tree to DLL
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
public: 
void solve(Node *root, Node* &head, Node* &prev, int &f)
{
    if(!root) return;
    
    solve(root->left, head, prev, f);
    if(f==0)
    {
        head = root;
        prev = root;
        f = 1;
    }
    else
    {
        prev->right = root;
        prev->right->left = prev;
        prev = prev->right;
    }
    solve(root->right, head, prev, f);
}

Node * bToDLL(Node *root)
{
    Node *head = NULL, *prev = NULL;
    int f = 0;
    solve(root, head, prev, f);
        
    return head;
}
----------------------------------------------------------------------------------------------
Q19) transform to sum tree
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
public:
  
int solve(Node *root)
{
    if(!root) return 0;
    
    int a = solve(root->left);
    int b = solve(root->right);
    int x = root->data;
    root->data = a + b;
    
    return a+b+x;
    
}
    
void toSumTree(Node *node)
{
    solve(node);
}
----------------------------------------------------------------------------------------------
Q20) Construct a binary Tree from Inorder & Preorder 
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
public:
int idx = 0;
unordered_map<int, int> m;
Node *solve(int pre[], int in[], int low, int high)
{
    if(low > high) return NULL;

    Node *res = new Node(pre[idx]);
    idx = idx + 1;
    if(low == high) return res;
    
    int mid = m[res->data];
    res->left = solve(pre, in, low, mid-1);
    res->right = solve(pre, in, mid+1, high);
    return res;
}

Node* buildTree(int in[],int pre[], int n)
{
     idx = 0;
     m.clear();
     for(int i=0; i<n; i++)
     {
         m[in[i]] = i;
     }
     Node *root = solve(pre, in, 0, n-1);
     
     return root;
}
----------------------------------------------------------------------------------------------
Q1**not) Minimum swap required to convert binary tree to binary search tree
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include<bits/stdc++.h>
using namespace std;

// Inorder Traversal of Binary Tree
void inorder(int arr[], vector<int> &v, int n, int index)
{
	// if index is greater or equal to vector size
	if(index >= n)
		return;
	inorder(arr, v, n, 2 * index + 1);
	
	// push elements in vector
	v.push_back(arr[index]);
	inorder(arr, v, n, 2 * index + 2);
}

int minSwaps(vector<int> &v)
{
	vector<pair<int,int>> t(v.size());
	int ans = 0;
	for(int i = 0; i < v.size(); i++)
		t[i].first = v[i], t[i].second = i;
	
	sort(t.begin(), t.end());
	for(int i = 0; i < t.size(); i++)
	{
		// second element is equal to i
		if(i == t[i].second)
			continue;
		else
		{
			swap(t[i].first, t[t[i].second].first);
			swap(t[i].second, t[t[i].second].second);
		}
		
		// Second is not equal to i
		if(i != t[i].second)
			i--;
		ans++;
	}
	return ans;
}

int main()
{
	int arr[] = { 5, 6, 7, 8, 9, 10, 11 };
	int n = sizeof(arr) / sizeof(arr[0]);
	vector<int> v;
	inorder(arr, v, n, 0);
	cout << minSwaps(v) << endl;
}
----------------------------------------------------------------------------------------------
Q21) check binary tree is sum tree or not
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
public:
int f = 1;
int solve(Node *root)
{
    if(!root) return 0;
    
    if(!root->left && !root->right) return root->data;
    
    if(f == 0) return 0;			//since time complexity reduced
    
    int a = solve(root->left);
    int b = solve(root->right);
    if(root->data != a+b) f = 0;
    return a + b + root->data;
}
    
bool isSumTree(Node* root)
{
    f = 1;
    solve(root);
    
    return f;
}
---------------------------------------------------------------------------------------------
Q22) check all leaf are at same level or not
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
int ans = 1;
void solve(Node *root,int h, int &ma)
{
    if(!root) return;
    if(ans == 0) return;
    if(!root->left && !root->right)
    {
        if(ma == -1) ma = h;            //for first leaf height
        else
        {
            if(h != ma) ans = 0;
        }
        return;
    }
    solve(root->left, h+1, ma);
    solve(root->right, h+1, ma);
}

bool check(Node *root)
{
    ans = 1;
    int ma = -1;
    int h = 0;
    solve(root, h, ma);
        
    return ans;
}
---------------------------------------------------------------------------------------------
Q23) Check if a Binary Tree contains duplicate subtrees of size 2 or more [ IMP ]
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
unordered_map<string, int> m;

string solve(Node *root)
{
    if(!root) return "$";
    string s = "";
    if(!root->left && !root->right)
    {
        s = to_string(root->data);
        return s;
    }
    s = s + to_string(root->data);
    s = s + solve(root->right);
    s = s + solve(root->left);
    m[s]++;
    return s;
}

int dupSub(Node *root) 
{
    m.clear();
    solve(root);
    for(auto x : m)
    {
        if(x.second >= 2) return true;
    }
    return false;
}
---------------------------------------------------------------------------------------------
Q24) Sum of the Longest Bloodline of a Tree (Sum of nodes on the longest path from root to leaf node) 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vector<int> solve(Node *root)
{
    if(!root) return {0,0};
    vector<int> a = solve(root->left);
    vector<int> b = solve(root->right);
    if(a[0] > b[0]) return {a[0]+1, a[1]+root->data};
    if(a[0] < b[0]) return {b[0] + 1, b[1]+root->data};
    else return {b[0]+1, max(a[1], b[1])+root->data};
}

int sumOfLongRootToLeafPath(Node *root)
{
    vector<int> ans = solve(root);
    return ans[1];
}
---------------------------------------------------------------------------------------------
Q25) Find largest subtree sum in a tree 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>
using namespace std;

struct Node 
{
    int key;
    Node *left, *right;
};

Node* newNode(int key)
{
    Node* temp = new Node;
    temp->key = key;
    temp->left = temp->right = NULL;
    return temp;
}

int ma = 0;
int findLargestSubtreeSum(Node *root)
{
    if(!root) return 0;
    int l = findLargestSubtreeSum(root->left);
    int r = findLargestSubtreeSum(root->right);
    ma = max(ma, l + r + root->key);
    return l + r + root->key;
}



int main()
{
	/*
		10
	       /   \
	      /	    \
	    -2	     3
	    / \	     / \
	   /   \    /   \
          4    5  -6	 2
				*/

	Node* root = newNode(10);
	root->left = newNode(-2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(-6);
	root->right->right = newNode(2);

	cout << findLargestSubtreeSum(root);
	return 0;
}
---------------------------------------------------------------------------------------------
Q26) Maximum sum of nodes in Binary tree such that no two are adjacent
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>		//dynamic programming method
using namespace std;

class Node 
{
public:
	int data;
	Node *left, *right;
	Node(int data)
	{
		this->data = data;
		left = NULL;
		right = NULL;
	}
};

unordered_map<Node*, int> m;
int maxsum(Node *root)
{
    if(!root) return 0;                 //base case
    if(m[root]) return m[root];         //memoization (if the max sum from the  node is already in map,return the value)
    
    int inc = root->data;
    if(root->left)
    {
        inc = inc + maxsum(root->left->left);
        inc = inc + maxsum(root->left->right);
    }
    if(root->right)
    {
        inc = inc + maxsum(root->right->left);
        inc = inc + maxsum(root->right->right);
    }
    
    int exc = maxsum(root->left) + maxsum(root->right);
    
    m[root] = max(inc,exc);
    return m[root];
    
}

int main()
{
	Node* root = new Node(10);
	root->left = new Node(1);
	root->left->left = new Node(2);
	root->left->left->left = new Node(1);
	root->left->right = new Node(3);
	root->left->right->left = new Node(4);
	root->left->right->right = new Node(5);
	cout << maxsum(root);
	return 0;
}
---------------------------------------------------------------------------------------------
Q27) Print all k-sum paths in a binary tree
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>
using namespace std;

struct Node 
{
	int data;
	Node *left, *right;
	Node(int x)
	{
		data = x;
		left = right = NULL;
	}
};

void func(Node *root, vector<int> &path, int k)
{
    if(!root) return;
    path.push_back(root->data);
    func(root->left, path, k);
    func(root->right, path, k);
    
    int f = 0;
    for(int j = path.size()-1; j >= 0; j--)
    {
        f = f + path[j];
        if(f == k)
        {
            for(int m = j; m<path.size(); m++)
                cout << path[m] << " ";
            cout << endl;
        }
    }
    path.pop_back();
}

int main()
{
	Node* root = new Node(1);
	root->left = new Node(3);
	root->left->left = new Node(2);
	root->left->right = new Node(1);
	root->left->right->left = new Node(1);
	root->right = new Node(-1);
	root->right->left = new Node(4);
	root->right->left->left = new Node(1);
	root->right->left->right = new Node(2);
	root->right->right = new Node(5);
	root->right->right->right = new Node(2);

	int k = 5;
	vector<int> path;
	func(root, path, k);
	return 0;
}
---------------------------------------------------------------------------------------------
Q28) Lowest Common Ancestor in a Binary Tree
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Node* lca(Node* root ,int n1 ,int n2 )
{
    if(!root) return NULL;
    if(root->data == n1 || root->data == n2) return root;
    
    Node *l = lca(root->left, n1, n2);
    Node *r = lca(root->right, n1, n2);
    
    if(l && r) return root;
    if(l) return l;
    if(r) return r;
}
---------------------------------------------------------------------------------------------
Q29) Min distance between two given nodes of a Binary Tree 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Node *lca(Node *root, int a, int b)
{
    if(!root) return NULL;
    if(root->data == a || root->data == b) return root;
    
    Node *l = lca(root->left, a, b);
    Node *r = lca(root->right, a, b);
    
    if(l && r) return root;
    if(l) return l;
    if(r) return r;
}

int solve(Node *root, int val, int level)
{
    if(!root) return -1;
    if(root->data == val) return level;
    
    int m = solve(root->left, val, level+1);
    if(m == -1)
    {
        return solve(root->right, val, level+1);
    }
        
    return m; 
}

int findDist(Node* root, int a, int b) 
{
    
    Node *LCA = lca(root, a, b);
    int x = solve(LCA, a,0);
    int y = solve(LCA, b,0);
    
    return x+y;
}
---------------------------------------------------------------------------------------------
Q30) Kth Ancestor in a Tree
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Node *solve(Node *root, int &k, int val)
{
    if(!root) return NULL;
    if(root->data == val) return root;
    
    Node *l = solve(root->left, k, val);
    Node *r = solve(root->right, k, val);
    
    if(l && !r)
    {
        k--;
        if(k == 0) return root;
        return l;
    }
    if(!l && r)
    {
        k--;
        if(k == 0) return root;
        return r;
    }
    return NULL;
}

int kthAncestor(Node *root, int k, int node)
{
    Node *ans = solve(root, k, node);
    
    if(ans == NULL || ans->data == node) 
    {
        return -1;
    }
    
    else 
    {
        return ans->data;
    }
}
---------------------------------------------------------------------------------------------
Q31) Check if Tree is Isomorphic 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
bool isIsomorphic(Node *root1,Node *root2)
{
    if(!root1 && !root2) return true;
    if(!root1 || !root2) return false;
    if(root1->data != root2->data) return false;
    
    bool a = isIsomorphic(root1->left, root2->left) && isIsomorphic(root1->right, root2->right);
    bool b = isIsomorphic(root1->left, root2->right) && isIsomorphic(root1->right, root2->left);
    return (a || b);
}
---------------------------------------------------------------------------------------------
Q32) 	Check if 2 trees are mirror or not
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
int checkMirrorTree(int n, int e, int A[], int B[]) 
{
    unordered_map<int, stack<int>> m;
    for(int i=0; i<2*e; i=i+2)
    {
        m[A[i]].push(A[i+1]);
    }
    
    for(int i=0; i<2*e; i=i+2)
    {
        if(m[B[i]].top() != B[i+1])
        {
            return 0;
        }
        
        m[B[i]].pop();
    }
    return 1;
}
---------------------------------------------------------------------------------------------
Q33) Find all Duplicate subtrees in a Binary tree [ IMP ]
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vector<Node*> v;
unordered_map<string, int> m;

string solve(Node *root)
{
    if(!root) return " ";
    string s = " ";
    
    if(!root->left && !root->right)
    {
        s = to_string(root->data);
        m[s]++;
    }
    
    s = s + to_string(root->data);
    s = s + solve(root->left);
    s = s + solve(root->right);
    
    if(m[s] == 1)
    {
        v.push_back(root);
    }
    m[s]++;
    return s;
}
vector<Node*> printAllDups(Node* root)
{
    v.clear();
    m.clear();
    solve(root);
    return v;
}
---------------------------------------------------------------------------------------------
