                    			******Greedy******
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Q1) Activity Selection Problem
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 								//gfg efficient sol
{
    public:
    //Function to find the maximum number of meetings that can
    //be performed in a meeting room.
    static bool comp(pair<int, int> a, pair<int, int> b)            //helper fun
    {
        if(a.second != b.second) return a.second < b.second;
        return a.first < b.first;
    }
    
    int maxMeetings(int start[], int end[], int n)                  //main fun
    {
        vector<pair<int, int>> v(n);
        for(int i=0; i<n; i++)
        {
            v[i] = {start[i], end[i]};
        }
        sort(v.begin(), v.end(), comp);
        
        int i=0;
        int j=1;
        int ans=1;
        while(j<n)
        {
            if(v[i].second < v[j].first)
            {
                ans++;
                i = j;
                j++;
            }
            else
            {
                j++;
            }
        }
        return ans;
    }
};
---------------------------------------------------------------------------------------------
Q2) Job SequencingProblem
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 								//gfg efficient sol
{
    public:
    //Function to find the maximum profit and the number of jobs done.
    static bool comp(Job a, Job b)
    {
        return a.profit > b.profit;
    }
    
    vector<int> JobScheduling(Job arr[], int n) 
    { 
        sort(arr, arr+n, comp);
        
        bool done[n] = {false};
        int jobs = 0;
        int profit = 0;
        for(int i=0; i<n; i++)
        {
            for(int j=min(n, arr[i].dead-1); j>=0; j--)
            {
                if(done[j] == false)
                {
                    jobs = jobs + 1;
                    profit = profit + arr[i].profit;
                    done[j] = true;
                    break;
                }
            }
        }
        return {jobs, profit};
    } 
};
---------------------------------------------------------------------------------------------
Q3) Water connection problem
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution
{
    public:
    void DFS(int node, vector<pair<int, int>> g[], int &minW, int &end, int vis[])	//helper fun
    {
        vis[node] = 1;
        for(auto e : g[node])
        {
            if(vis[e.first] == 0)
            {
                minW = min(minW, e.second);
                end = e.first;
                DFS(e.first, g, minW, end, vis);
            }
        }
    }
    
    vector<vector<int>> solve(int n,int p,vector<int> a,vector<int> b,vector<int> d)	//main fun
    {
        int vis[n+1];
        vector<vector<int>> ans;
        memset(vis, 0, sizeof(vis));
        vector<int> in(n+1, 0);
        vector<int> out(n+1, 0);
        vector<pair<int, int>> g[n+1];
        
        for(int i=0; i<p; i++)
        {
            out[a[i]] = 1;
            in[b[i]] = 1;
            g[a[i]].push_back({b[i], d[i]});
        }
        
        for(int i=1; i<=n; i++)
        {
            if(in[i] == 0 && out[i] == 1 && vis[i] == 0)
            {
                int start = i;
                int end;
                int min_Wt = INT_MAX;
                DFS(i, g, min_Wt, end, vis);
                ans.push_back({start, end, min_Wt});
            }
        }
        return ans;
    }
};
---------------------------------------------------------------------------------------------
Q4) Fractional lnapsack
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 // } Driver Code Ends
//class implemented
/*
struct Item{
    int value;
    int weight;
};
*/

class Solution
{
    public:
    //Function to get the maximum total value in the knapsack.
    double fractionalKnapsack(int W, Item arr[], int n)
    {
        vector<pair<double, int>> v;
        for(int i=0; i<n; i++)
        {
            double x = (arr[i].value*1.0) / (arr[i].weight*1.0);
            v.push_back({x,i});
        }
        sort(v.begin(), v.end(), greater<pair<double, int>>());
        double ans = 0;
        int s = 0;
        for(int i=0; i<n; i++)
        {
            if(s + arr[v[i].second].weight < W)
            {
                s = s + arr[v[i].second].weight;
                ans = ans + arr[v[i].second].value;
            }
            else
            {
                double x = (W - s)*1.0;
                ans = ans + (x * v[i].first);
                break;
            }
        }
        return ans;
    }
};
---------------------------------------------------------------------------------------------
Q5) Minimum number of coins
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
public:
    vector<int> minPartition(int X)
    {
        vector<int> A = {1, 2, 5, 10, 20, 50, 100, 200, 500, 2000 };
        vector<int> ans;
        int n = A.size();
        for(int i=n-1; i>=0; i--)
        {
            while(A[i] <= X)
            {
                ans.push_back(A[i]);
                X = X - A[i];
            }
        }
        return ans;
    }
};
---------------------------------------------------------------------------------------------
Q6) Choose and swap problem
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
public:
    string chooseandswap(string str)
    {
        set<char> s;
        for(int i=0; i<str.size(); i++)
        {
            s.insert(str[i]);
        }
        
        for(int i=0; i<str.size(); i++)
        {
            s.erase(str[i]);
            if(s.empty()) break;
            char ch1 = *s.begin();
            char ch2 = str[i];
            if(ch1 < str[i])
            {
                for(int j=0; j<str.size(); j++)
                {
                    if(ch1 == str[j]) str[j] = ch2;
                    else if(ch2 == str[j]) str[j] = ch1;
                }
                break;
            }
        }
        return str;
    }
    
};
---------------------------------------------------------------------------------------------
Q7) Minimum platform problem
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
    public:
    //Function to find the minimum number of platforms required at the
    //railway station such that no train waits.
    int findPlatform(int arr[], int dep[], int n)
    {
    	sort(arr, arr+n);
    	sort(dep, dep+n);
    	
    	int no_plat = 1;
    	int i = 1;
    	int j = 0;
    	while(i<n)
    	{
    	    if(arr[i] <= dep[j]) no_plat++;
    	    else j++;
    	    i++;						//i ince. evry time
    	}
    	return no_plat;
    }
};
---------------------------------------------------------------------------------------------
Q8) Buy Maximum Stocks if i stocks can be bought on i-th day
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol 
{
public:
    int buyMaximumProducts(int n, int k, int arr[])
    {
        vector<pair<int, int>> v;
        for(int i=0; i<n; i++)
        {
            v.push_back({arr[i], i+1});
        }
        sort(v.begin(), v.end());
        
        int ans = 0;
        for(int i=0; i<n; i++)
        {
            int price = v[i].first;
            int stocks = v[i].second;
            if(price * stocks <= k)
            {
                ans = ans + stocks;
                k = k - price * stocks;
            }
            else
            {
                ans = ans + (k/price);
                k = k - price * (k/price);
            }
        }
        return ans;
    }
};
---------------------------------------------------------------------------------------------
Q9) Find the minimum and maximum amount to buy all N candies
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
public:
    vector<int> candyStore(int candi[], int n, int K)
    {
        vector<int> ans;
        sort(candi, candi+n);
        
        int min = 0;
        int i=0, j=n-1;
        while(i <= j)
        {
            min = min + candi[i];
            i++;
            j = j-K;
        }
        
        int max = 0;
        i=0, j=n-1;
        while(i <= j)
        {
            max = max + candi[j];
            j--;
            i = i+K;
        }
        
        return {min, max};
    }
};
---------------------------------------------------------------------------------------------
Q10) Minimum Cost to cut a board into squares
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
public:
    int minimumCostOfBreaking(vector<int> X, vector<int> Y, int n, int m)
    {
        sort(X.rbegin(), X.rend());			//sort descending order X and Y
        sort(Y.rbegin(), Y.rend());
        
        int ans = 0;
        int verC=1, horC=1;
        
        int i=0, j=0;
        while(i<n && j<m)
        {
            if(X[i] > Y[j])
            {
                ans = ans + X[i]*verC;
                horC++;
                i++;
            }
            else
            {
                ans = ans + Y[j]*horC;
                verC++;
                j++;
            }
        }
        
        while(i<n)
        {
            ans = ans + X[i]*verC;
            i++;
        }
        
        while(j<m)
        {
            ans = ans + Y[j]*horC;
            j++;
        }
        return ans;
    }
};
---------------------------------------------------------------------------------------------
Q11) Check if it is possible to survive on Island
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
public:
    int minimumDays(int S, int N, int M)
    {
        int C_sun = S/7;
        int buy_d = S - C_sun;                      //maxi #of days to buy
        int need = S*M;
        
        int ans;
        if(need % N == 0) ans = need / N;
        else ans = (need / N) + 1;
        
        if(ans <= buy_d) return ans;                //survive possible
        else return -1;                             //survive not possible
    }
};
---------------------------------------------------------------------------------------------
Q12) Maximum Meetings in One Room
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution							//gfg practice efficient sol
{
public:
static bool comp(pair<pair<int, int>, int> a, pair<pair<int, int>, int> b)            //helper fun
    {
        if(a.first.second != b.first.second) return a.first.second < b.first.second;
        return a.second < b.second;
    }
    
    vector<int> maxMeetings(int n, vector<int> &start, vector<int> &end)		//main fun
    {
        vector<pair<pair<int, int>, int>> v(n);
        vector<int> ans;
        for(int i=0; i<n; i++)
        {
            v[i] = {{start[i], end[i]}, i+1};
        }
        sort(v.begin(), v.end(), comp);
        
        int i=0;
        int j=1;
        ans.push_back(v[0].second);
        while(j<n)
       {
            if(v[i].first.second < v[j].first.first)
            {
                ans.push_back(v[j].second);
                i = j;
                j++;
            }
            else
            {
                j++;
            }
        }
        sort(ans.begin(), ans.end());
        return ans;
    }
}; 
---------------------------------------------------------------------------------------------
Q13) Maximum product subset of an array
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
    public:
    long long int findMaxProduct(vector<int>&a, int n)
    {
        if(n == 1) return a[0];                 //base condition
        
        int mod = 1e9 + 7;
        long long int pro = 1;
        int zero_c = 0;
        int neg_c = 0;
        int max_neg = INT_MIN;
        
        for(int i=0; i<n; i++)
        {
            if(a[i] == 0)
            {
                zero_c++;
                continue;
            }
            else if(a[i] < 0)
            {
                neg_c++;
                max_neg = max(max_neg, a[i]);
            }
            pro = (pro * a[i]) % mod;
        }
        
        if(zero_c == n) return 0;
        else if(neg_c == 1 && zero_c == n-1) return 0;
        else if(neg_c % 2 == 1) pro = pro / max_neg;
        
        return pro % mod;
    }
};
---------------------------------------------------------------------------------------------
Q14) Maximize sum after K negations
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution                                  			   //gfg brute force
{
    public:
    long long int maximizeSum(long long int a[], int n, int k)
    {
        for(int i=0; i<k; i++)
        {
            int min_e = INT_MAX;
            int indx = -1;
            
            for(int j=0; j<n; j++)                  //find min ele. from a[]
            {
                if(a[j] < min_e)
                {
                    min_e = a[j];
                    indx = j;
                }
            }
            if(min_e == 0) break;
            else                                    //replace min ele. with its negation
            {
                a[indx] = -a[indx];
            }
        }
        long long int sum = 0;
        for(int i=0; i<n; i++)
        {
            sum = sum + a[i];
        }
        return sum;
    }
};
---------------------------------------------------------------------------------------------
class Solution                                  			//gfg efficient sol
{
    public:
    long long int maximizeSum(long long int a[], int n, int k)
    {
        sort(a, a+n);
        for(int i=0; i<n; i++)
        {
            if(a[i]<0 && k>0)
            {
                a[i] = -a[i];
                k--;
            }
        }
        
        int sum = 0;
        for(int i=0; i<n; i++)
            sum = sum + a[i];
            
        int x = *min_element(a, a+n);
        if(k%2 == 1) sum = sum - 2*x;
        return sum;
    }
};
---------------------------------------------------------------------------------------------
Q15) Maximize sum(arr[i]*i) of an Array
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
    public:
    int Maximize(int a[],int n)
    {
        int mod = 1e9 + 7;
        sort(a, a+n);
        
        long long int ans = 0;
        for(long long int i=0; i<n; i++)
        {
            ans = (ans + a[i]*i) % mod;
        }
        
        return ans%mod;
    }
};
---------------------------------------------------------------------------------------------
Q16) Minimum Sum of Absolute Differences of Pairs 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
public:
    long long findMinSum(vector<int> &A,vector<int> &B,int n)
    {
        sort(A.begin(), A.end());
        sort(B.begin(), B.end());
        
        long long sum = 0;
        for(int i=0; i<n; i++)
        {
            sum = sum + abs(A[i] - B[i]);
        }
        
        return sum;
    }
};
---------------------------------------------------------------------------------------------
Q17) Maximum sum of absolute difference of any permutation
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>							//gfg article
using namespace std;

int MaxSumDifference(vector<int> &arr, int n)
{
    sort(arr.begin(), arr.end());
    vector<int> per;						//make per 
    for(int i=0; i<n/2; i++)
    {
        per.push_back(arr[i]);
        per.push_back(arr[n-i-1]);
    }
    if(n%2 == 1) per.push_back(arr[n/2]);
    
    int sum = 0;						//calculate maxi sum
    for(int i=0; i<n-1; i++)
    {
        sum = sum + abs(per[i] - per[i+1]);
    }
    sum = sum + abs(per[n-1] - per[0]);
    return sum;
}

int main()
{
	vector<int>arr = { 1, 2, 4, 8, 11 };
	cout << MaxSumDifference(arr, 5) << endl;
}
---------------------------------------------------------------------------------------------
Q18) Swap and Maximize (Maximize sum of consecutive differences in a circular array)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
long long int maxSum(int arr[], int n)					 //gfg efficient sol
{
    sort(arr, arr+n);
    
    long long int sum = 0;
    for(int i=0; i<n/2; i++)
    {
        sum = sum - 2*arr[i];
        sum = sum + 2*arr[n-i-1];
    }
    return sum;
}
---------------------------------------------------------------------------------------------
Q19) Minimum Sum of Absolute Differences of Pairs 	//q16 also exactly same
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
public:
    long long findMinSum(vector<int> &A,vector<int> &B,int n)
    {
        sort(A.begin(), A.end());
        sort(B.begin(), B.end());
        
        long long sum = 0;
        for(int i=0; i<n; i++)
        {
            sum = sum + abs(A[i] - B[i]);
        }
        
        return sum;
    }
};
---------------------------------------------------------------------------------------------
Q20) Program for Shortest Job First (or SJF) CPU Scheduling | Set 1 (Non- preemptive)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>							//gfg article
using namespace std;

bool comp(vector<int> p, vector<int> q)             	//helper fun
{
    if(p[1] != q[1]) return p[1] < q[1];
    else
    {
        if(p[2] != q[2]) return p[2] < q[2];
        else return p[0] < q[0];
    }
}

int main()                                          	//main fun
{
	int n;
	cout << "no of process id's:-";
	cin >> n;
	vector<vector<int>> v(n);                       //taking input
	for(int i=0; i<n; i++)
	{
	    for(int j=0; j<3; j++)
	    {
	        int x;
	        cin >> x;
	        v[i].push_back(x);
	    }
	    
	}
	vector<int> ans;
	sort(v.begin(), v.end(), comp);
	priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
	pq.push({v[0][2], v[0][1], v[0][0]});
	int i = 1;
	int curr_t = 0;
	
	while(!pq.empty())
	{
	    int bur_t = pq.top()[0];
	    int id = pq.top()[2];
	    pq.pop();
	    ans.push_back(id);
	    curr_t = curr_t + bur_t;
	    while(true)
	    {
	        if(i<n && v[i][1] <= curr_t)
	        {
	            pq.push({v[i][2], v[i][1], v[i][0]});
	            i++;
	        }
	        else break;
	    }
	}
	
	cout<< "output:- "; 
	for(int j=0; j<ans.size(); j++)
	    cout << ans[j] << " ";
}
----------------------------------------
no of process id's:-5
1 2 3
2 0 4
3 4 2
4 5 4
5 5 2
output:- 2 3 5 1 4 
---------------------------------------------------------------------------------------------
Q21) Smallest Subset with Greater Sum
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
    public:
    int minSubset(vector<int> &arr, int n)
    {
        long long sum = 0;
        for(int i=0; i<n; i++)
            sum = sum + arr[i];
            
        sort(arr.rbegin(), arr.rend());
        long long x = 0;
        for(int i=0; i<n; i++)
        {
            sum = sum - arr[i];
            x = x + arr[i];
            if(x > sum) return i+1;
        }
        return n;
    }
};
---------------------------------------------------------------------------------------------
Q22) Chocolate Distribution Problem (exactly same to array Q29)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
    public:
    long long findMinDiff(vector<long long> arr, long long n, long long m)
    {
        sort(arr.begin(), arr.end());
        long long ans = LONG_LONG_MAX;
        
        for(int i=0; i+m-1<n; i++)
        {
            long long currM = arr[i+m-1] - arr[i];
            ans = min(ans, currM);
        }
        return ans;
    }   
};
---------------------------------------------------------------------------------------------
Q23) DEFKIN - Defense of a Kingdom
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int t;
    cin >> t;
    while(t--)
    {
        int w, h, n;
        cin >> w >> h >> n;
        vector<int> a;
        vector<int> b;
        a.push_back(0);
        b.push_back(0);
        
        for(int i=0; i<n; i++)
        {
            int x, y;
            cin >> x >> y;
            a.push_back(x);
            b.push_back(y);
        }
        a.push_back(w+1);
        b.push_back(h+1);
        
        sort(a.begin(), a.end());
        sort(b.begin(), b.end());
        
        int maxW = 0, maxH = 0;
        for(int i=0; i<a.size()-1; i++)
        {
            maxW = max(maxW, a[i+1]-a[i]-1);
            maxH = max(maxH, b[i+1]-b[i]-1);
        }
        cout << maxW*maxH;
    }
}

input:-
1
15 8 3
3 8
11 2
8 6
ouput:-12
---------------------------------------------------------------------------------------------
Q24) DIEHARD -DIE HARD
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>
using namespace std;

int dp[1001][1001];
int solve(int h, int a, int i)                      //helper function
{
    if(h<=0 || a<=0) return 0;                      //base condition
    if(dp[h][a] != -1) return dp[h][a];             //for memoization
    
    int x=0, y=0, z=0;
    if(i != 1) x = 1 + solve(h+3, a+2, 1);
    if(i != 2) y = 1 + solve(h-5, a-10, 2);
    if(i != 3) z = 1 + solve(h-20, a+5, 3);
    dp[h][a] = max({x, y, z});
}

int main()
{
    int t;
    cin >> t;
    while(t--)
    {
        int h, a;
        cin >> h >> a;
        memset(dp, -1, sizeof(dp));
        cout << max( {solve(h+3, a+2, 1), 
                      solve(h-5, a-10, 2), 
                      solve(h-20, a+5, 3)} ) << endl;
    }
}

input:-
3
2 10
4 4
20 8
 
output:-1 1 5
---------------------------------------------------------------------------------------------
Q25) GERGOVIA -Wine trading in Gergovia
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n;
    cin >> n;
    while(true)
    {
        int a[n];
        for(int i=0; i<n; i++) cin >> a[i];
        vector<pair<int, int> > buy;
        vector<pair<int, int> > sel;
        for(int i=0; i<n; i++)
        {
            if(a[i] > 0) buy.push_back({a[i], i});
            else sel.push_back({a[i], i});
        }
        
        int ans = 0;
        int i=0, j=0;
        while(i<buy.size() && j<sel.size())
        {
            int x = min(buy[i].first, -sel[j].first);
            buy[i].first -= x;
            sel[j].first += x;
            ans += x*abs(buy[i].second - sel[j].second);
            if(buy[i].first == 0) i++;
            if(sel[j].first == 0) j++;
        }
        cout << ans << endl;
        cin >> n;
        if(n == 0) break;
    }
    return 0;
}

input:-
5
5 -4 1 -3 1
output:- 9
---------------------------------------------------------------------------------------------
Q26) 	ARRANGE -Arranging Amplifiers 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int t;
    cin >> t;
    while(t--)
    {
        int n;
        cin >> n;
        int a[n];
        int oneC = 0;
        for(int i=0; i<n; i++)
        {
            cin >> a[i];
            if(a[i] == 1) oneC++;
        }
        sort(a, a+n, greater<int>());
        
        for(int i=0; i<oneC; i++) 
            cout << "1 ";
        if(n-oneC == 2 && a[0] == 3 && a[1] == 2) 
            cout << "2 3 " << endl;
        else
        {
            for(int i=0; i<n-oneC; i++)
                cout << a[i] << " ";
            cout << endl;
        }
    }
    return 0;
}

3		-#of test case
3		-test case-1
2 3 4
4 3 2 
5		-test case-2
1 3 4 1 1
1 1 1 4 3 
4		-test case-3
1 3 2 1
1 1 2 3 

---------------------------------------------------------------------------------------------
Q27) Minimum Cost of ropes 		//heap Q13 eactly same
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution
{
    public:
    //Function to return the minimum cost of connecting the ropes.
    long long minCost(long long arr[], long long n) 
    {
        priority_queue<long long, vector<long long>, greater<long long>> pq;
        
        for(int i=0; i<n; i++)
        {
            pq.push(arr[i]);
        }
        
        long long cost = 0;
        while(pq.size() >= 2)
        {
            long long a = pq.top();
            pq.pop();
            long long b = pq.top();
            pq.pop();
            
            cost = cost + a + b;
            pq.push(a + b);
        }
        
        return cost;
    }
};
---------------------------------------------------------------------------------------------
Q28) Find smallest number with given number of digits and sum of digits
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{   
public:
    string smallestNumber(int sum, int d)
    {
        if(9*d < sum) return "-1";
        string ans;
        for(int i=d-1; i>= 0; i--)
        {
            if(sum > 9) 
            {
                ans = '9' + ans;
                sum = sum - 9;
            }
            else
            {
                if(i == 0) ans = to_string(sum) + ans;
                else
                {
                    ans = to_string(sum-1) + ans;
                    i--;
                    while(i > 0)
                    {
                        ans = '0' + ans;
                        i--;
                    }
                    ans = '1' + ans;
                }
            }
        }
        return ans;
    }
};
---------------------------------------------------------------------------------------------
Q29) Find Maximum Equal sum of Three Stacks
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{
public:
    int maxEqualSum(int n1,int n2,int n3,vector<int> &s1,vector<int> &s2,vector<int> &s3)
    {
        int sum1 = 0, sum2 = 0, sum3 = 0;
        for(int i=0; i<n1; i++) sum1 = sum1 + s1[i];
        for(int i=0; i<n2; i++) sum2 = sum2 + s2[i];
        for(int i=0; i<n3; i++) sum3 = sum3 + s3[i];
        
        int top1=0, top2=0, top3=0;
        int ans = 0;
        while(true)
        {
            if(top1==n1 || top2==n2 || top3==n3)            //not possible
            {
                ans = 0;
                break;
            }
            
            if(sum1 == sum2 && sum2 == sum3)                //all 3 sums are equal
            {
                ans = sum1;
                break;
            }
            
            if(sum1 >= sum2 && sum1 >= sum3)            //sum1 is largest
            {
                sum1 = sum1 - s1[top1];
                top1++;
            }
            else if(sum2 >= sum1 && sum2 >= sum3)       //sum2 is largest
            {
                sum2 = sum2 - s2[top2];
                top2++;
            }
            else if(sum3 >= sum1 && sum3 >= sum2)       //sum3 is largest
            {
                sum3 = sum3 - s3[top3];
                top3++;
            }
        }
        return ans;
    }
};
---------------------------------------------------------------------------------------------