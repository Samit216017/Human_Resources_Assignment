                    			  ******Array******
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Q1) Reverse array
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <iostream>
using namespace std;

int main() 
{
	int t, n;
	cin >> t;
	while(t--)
	{
	    cin >> n;
	    int arr[n];
	    for(int i=0; i<n; i++)
	    {
	        cin >> arr[i];
	    }
	    
	    for(int i=n-1; i>=0; i--)
	    {
	        cout << arr[i] << " ";
	    }
	    cout << endl;
	}
	return 0;
}
---------------------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

void rvereseArray(int arr[], int start, int end)
{
	while(start < end)
	{
	    swap(arr[start], arr[end]);
	    start++;
	    end--;
	}
}	

int main()
{
	int arr[] = {1, 2, 3, 4, 5, 6};
	
	rvereseArray(arr, 0, 5);
	
	for(int i=0; i<6; i++)
        cout << arr[i] << " ";
	
	return 0;
}
---------------------------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

void rvereseArray(int arr[], int start, int end)
{
	if(start >= end) return;
	swap(arr[start], arr[end]);
	
	rvereseArray(arr, start + 1, end - 1);              	// Recursive Function calling
}	

int main()
{
	int arr[] = {1, 2, 3, 4, 5, 6};
	
	rvereseArray(arr, 0, 5);
	
	for(int i=0; i<6; i++)
        cout << arr[i] << " ";
	
	return 0;
}
---------------------------------------------------------------------------------------------
Q2) 	Find the maximum and minimum element in an array
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
pair<long long, long long> getMinMax(long long arr[], int n) 
{
    long long mn = INT_MAX;
    long long mx = INT_MIN;
    for(int i=0; i<n; i++)
    {
        mn = min(mn, arr[i]);
        mx = max(mx, arr[i]);
    }
    pair<long long, long long> p;
    p.first = mn;
    p.second = mx;
    return p;
}
---------------------------------------------------------------------------------------------
Q3) Kth smallest and largest element in an unsorted array             **heap Q5**
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <iostream>						//brute force
#include <algorithm>
using namespace std;

int main()
{
    int arr[] = { 12, 3, 5, 7, 19, 34, 55 };
    int n = sizeof(arr) / sizeof(arr[0]);
    int k = 2;
    
    sort(arr, arr+n);
    
    cout << "kth largest element in array : " << arr[n-k];
    cout << endl;
    cout << "kth smallest element in array : " << arr[k-1];
    return 0;
}

---------------------------------------------------------------------------------------------
class Solution							//gfg practice
{
    public:
    // arr : given array
    // l : starting index of the array i.e 0
    // r : ending index of the array i.e size-1
    // k : find kth smallest element and return using this function
int kthSmallest(int arr[], int l, int r, int k) 
{
    priority_queue<int> pq;
    for(int i=0; i<=r; i++)
    {
        pq.push(arr[i]);
        if(pq.size() > k)
        {
            pq.pop();
        }
    }
    return pq.top();
}
};

""""""""""""""""""""""""""
Input:
N = 5
arr[] = 7 10 4 20 15
K = 4
Output : 15
---------------------------------------------------------------------------------------------
class Solution 							//leetcode practice
{
public:
    int findKthLargest(vector<int>& nums, int k) 
    {
        int n = nums.size();
        priority_queue<int, vector<int>, greater<int>> pq;
        for(int i=0; i<n; i++)
        {
            pq.push(nums[i]);
            if(pq.size() > k)
            {
                pq.pop();
            }
        }
        return pq.top(); 
    }
};
""""""""""""""""""""""""""
Input:
N = 5
arr[] = 7 10 4 20 15
K = 3
Output : 10
---------------------------------------------------------------------------------------------
Q4) Given an array which consists of only 0, 1 and 2. Sort the array without using any sorting algo
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//brute foce
{
    public:
    void sort012(int arr[], int n)
    {
        sort(arr, arr+n);
    }
};
---------------------------------------------------------------------------------------------
class Solution						//efficient sol:- 2 traversal
{
    public:
    void sort012(int arr[], int n)
    {
        int z = 0, o = 0, t = 0;
        for(int i=0; i<n; i++)
        {
            if(arr[i] == 0) z++;
            else if(arr[i] == 1) o++;
            else t++;
        }
        
        for(int i=0; i<n; i++)
        {
            if(z-- > 0) arr[i] = 0;
            else if(o-- > 0) arr[i] = 1;
            else arr[i] = 2;
        }
    }
};
---------------------------------------------------------------------------------------------
class Solution						//efficient sol:- 1 traversal
{
    public:
    void sort012(int arr[], int n)
    {
        int low = 0, mid = 0, high = n-1;
        while(mid <= high)
        {
            if(arr[mid] == 0) swap(arr[low++], arr[mid++]);
            else if(arr[mid] == 1) mid++;
            else if(arr[mid] == 2) swap(arr[mid], arr[high--]);
        }
    }
};
---------------------------------------------------------------------------------------------
Q5) Move all the negative elements to one side of the array
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>
using namespace std;

void reArrange(int arr[], int n)
{
    /*sort(arr, arr+n);*/                                   //brute force   ---1)
    
    /*int j=0;                                              //efficient     ---2)
    for(int i=0; i<n; i++)
    {
        if(arr[i] < 0)
        {
            if(i != j) swap(arr[i], arr[j]);
            j++;
        }
    }*/
    
    int low = 0, high = n-1;                                //efficient     ---3)
    while(low <= high)
    {
        if(arr[low] < 0) low++;
        else if(arr[high] > 0) high--;
        else swap(arr[low++], arr[high++]);
    }
}

int main() 
{
	int arr[] = {1, 2, -4, -5, 2, -7, 3, 2, -6};
	int n = sizeof(arr)/sizeof(arr[0]);
	reArrange(arr,n);

    	for(int i=0; i<n; i++)
        cout << arr[i] << " ";
    
	return 0;
}
---------------------------------------------------------------------------------------------
Q6) Find the Union and Intersection of the two sorted arrays.
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution							//brute force
{
    public:
    //Function to return the count of number of elements in union of two arrays.
    int doUnion(int a[], int n, int b[], int m)  
    {
        set<int> s;
        for(int i=0; i<n; i++)
            s.insert(a[i]);
            
        for(int j=0; j<m; j++)
            s.insert(b[j]);
            
        return s.size();
    }
};
---------------------------------------------------------------------------------------------
class Solution							//efficient sol
{
    public:
    //Function to return the count of number of elements in union of two arrays.
    int doUnion(int a[], int n, int b[], int m)  
    {
        set<int> s;
        int mn = min(m, n);
        for(int i=0; i<mn; i++)
        {
            s.insert(a[i]);
            s.insert(b[i]);
        }
        
        if(n > m)
        {
            for(int i=m; i<n; i++)
                s.insert(a[i]);
        }

        if(m > n)
        {
            for(int i=n; i<m; i++)
                s.insert(b[i]);
        }
        
        return s.size();
    }
};
---------------------------------------------------------------------------------------------
Q7) 	Write a program to cyclically rotate an array by one.
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
void rotate(int arr[], int n)
{
    int k = arr[n-1];
    for(int i=n-1; i>=1; i--)
    {
        arr[i] = arr[i-1];
    }
    arr[0] = k;
}
---------------------------------------------------------------------------------------------
void rotate(int arr[], int n)
{
    int i=0, j=n-1;
    while(i != j)
    {
        swap(arr[i], arr[j]);
        i++;
    }
}
---------------------------------------------------------------------------------------------
Q8) find Largest sum contiguous Subarray [V. IMP] (Kadane's Algorithm)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution						//same Q in heap Q10
{
    public:
    // arr: input array
    // n: size of array
    //Function to find the sum of contiguous subarray with maximum sum.
    long long maxSubarraySum(int arr[], int n)
    {
        int maximum = INT_MIN;
        int curr_max = 0;
        for(int i=0; i<n; i++)
        {
            curr_max = curr_max + arr[i];
            if(curr_max > maximum) maximum = curr_max;
            if(curr_max < 0) curr_max = 0;
        }
        return maximum;
        
    }
};
---------------------------------------------------------------------------------------------
Q9) 	Minimise the maximum difference between heights [V.IMP]
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 
{
  public:
    int getMinDiff(int arr[], int n, int k) 
    {
        sort(arr, arr+n);
        int mx = arr[n-1];
        int mn = arr[0];
        int diff = mx - mn;
        
        for(int i=0; i<n; i++)
        {
            if(arr[i] - k < 0) continue;
            
            mn = min(arr[0] + k, arr[i] - k);
            mx = max(arr[n-1] - k, arr[i-1] + k);
            
            diff = min(diff, mx - mn);
        }
        return diff;
    }
};
---------------------------------------------------------------------------------------------
Q10) 	Minimum no. of Jumps to reach end of an array
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution							//efficient sol
{
  public:
    int minJumps(int arr[], int n)
    {
        int jumps = 1;
        int steps = arr[0];
        int maxR = arr[0];
        
        if(n <= 1) return 0;
        else if(arr[0] == 0) return -1;
        else
        {
            for(int i=1; i<n; i++)
            {
                if(i == n-1) return jumps;
                maxR = max(maxR, i+arr[i]);
                steps--;
                
                if(steps == 0)
                {
                    jumps++;
                    if(i >= maxR) return -1;
                    steps = maxR - i;
                }
            }
        }
    }
};
---------------------------------------------------------------------------------------------
Q11)	find duplicate in an array of N+1 Integers
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 							//Leetcode- brute force
{
public:
    int findDuplicate(vector<int>& nums) 
    {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        for(int i=1; i<n; i++)
        {
            if(nums[i] == nums[i-1]) return nums[i];
        }
        return -1;
    }
};
---------------------------------------------------------------------------------------------
class Solution 							//Leetcode- better sol
{
public:
    int findDuplicate(vector<int>& nums) 
    {
        unordered_set<int> s;
        for(auto x : nums)
        {
            if(s.count(x)) return x;
            s.insert(x);
        }
        return -1;
    }
};
---------------------------------------------------------------------------------------------
class Solution							//gfg practice
{
  public:
    vector<int> duplicates(int arr[], int n) 
    {
        int count = 0;
        vector<int> v;
        sort(arr,arr+n);
        for(int i=0; i<n-1; i++)
        {
            if(arr[i] == arr[i+1])
            {
                count++;
                if(count==1)
                    v.push_back(arr[i]);
            }
            else
            {
                count=0;
            }
        }
        if(v.size()==0)
            v.push_back(-1);
        
        return v;
    }
};
---------------------------------------------------------------------------------------------
Q12) Merge 2 sorted arrays without using Extra space.
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//brute force
{
public:
	void merge(int arr1[], int arr2[], int n, int m) 
	{
	    priority_queue<int, vector<int>, greater<int>> pq;
	    
	    for(int i=0; i<n; i++)
	        pq.push(arr1[i]);
	    
	    for(int i=0; i<m; i++)
	        pq.push(arr2[i]);
	    
	    for(int i=0; i<n; i++)
	    {
	        arr1[i] = pq.top();
	        pq.pop();
	    }
	    
	    for(int i=0; i<m; i++)
	    {
	        arr2[i] = pq.top();
	        pq.pop();
	    }
	}
};
---------------------------------------------------------------------------------------------
class Solution								//efficient sol
{
public:
	void merge(int arr1[], int arr2[], int n, int m) 
	{
	    int i=n-1, j=0;
	    while(i >= 0 && j < m)
	    {
	        if(arr1[i] >= arr2[j])
	        {
	            swap(arr1[i], arr2[j]);
	            i--;
	            j++;
	        }
	        else
	        {
	            break;
	        }
	    }
	    
	    sort(arr1, arr1+n);
	    sort(arr2, arr2+m);
	}
};
---------------------------------------------------------------------------------------------
Q13) Kadane's Algo [V.V.V.V.V IMP]
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//brute force
{
    public:
    // arr: input array
    // n: size of array
    //Function to find the sum of contiguous subarray with maximum sum.
    long long maxSubarraySum(int arr[], int n)
    {
        int maxi = arr[0];
        for(int i=0; i<n; i++)
        {
            int curr = 0;
            for(int j=i; j<n; j++)
            {
                curr = curr + arr[j];
                maxi = max(maxi, curr);
            }
        }
        return maxi;
    }
};
---------------------------------------------------------------------------------------------
Note:- Q8) code is not work on Leetcode (same question)

class Solution								//gfg practice
{
    public:
    // arr: input array
    // n: size of array
    //Function to find the sum of contiguous subarray with maximum sum.
    long long maxSubarraySum(int arr[], int n)
    {
        int maximum = arr[0];
        int curr_max = arr[0];
        
        for(int i=1; i<n; i++)
        {
            curr_max = max(arr[i], curr_max + arr[i]);
            maximum = max(curr_max, maximum);
            
        }
        return maximum;        
    }
};
---------------------------------------------------------------------------------------------
class Solution 								//Leetcode
{
public:
    int maxSubArray(vector<int>& nums) 
    {
        int maximum = nums[0];
        int curr_max = nums[0];
        
        for(int i=1; i<nums.size(); i++)
        {
            curr_max = max(nums[i], curr_max + nums[i]);
            maximum = max(curr_max, maximum);
        }
        
        return maximum;
    }
};
---------------------------------------------------------------------------------------------
Q14) 	Merge Overlapping Intervals //same question 18) in stack & queue
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution {							//Leetcode sol
public:
vector<vector<int>> merge(vector<vector<int>>& intervals) 
{
   vector<vector<int>> ans = {};
    
    if(intervals.size() == 0) return ans;
    
    sort(intervals.begin(), intervals.end());
    vector<int> temp = intervals[0];		//x = [1,3] --> x[0]= 1 & x[1]=3
    for(auto x : intervals)
    {
        if(x[0] <= temp[1])
            temp[1] = max(temp[1], x[1]);
        else
        {
            ans.push_back(temp);
            temp = x;
        }
    }
    ans.push_back(temp);
    return ans;
}
};
----------------------------------------------------------------------------------------------
Q15) next permutation
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 							//Leetcode:- efficient sol
{					
public:
    void nextPermutation(vector<int> &a)
    {
        int idx = -1;
        int n = a.size();
        for(int i=n-1; i>0; i--)
        {
            if(a[i] > a[i-1]) 
            {
                idx = i;
                break;
            }
        }
        
        if(idx == -1)
        {
            reverse(a.begin(), a.end());
        }
        else
        {
            int prev = idx;
            for(int i=idx+1; i<n; i++)
            {
                if(a[idx-1] < a[i] && a[i] <= a[prev]) prev = i;
            }
            swap(a[idx-1], a[prev]);
        
            reverse(a.begin()+idx, a.end());    
        }        
    }
};
----------------------------------------------------------------------------------------------
Q16) count inversions
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
long long int inversionCount(long long arr[], long long n)		//brute force
{
    long long count = 0;
    for(int i=0; i<n-1; i++)
    {
        for(int j=i+1; j<n; j++)
        {
            if(arr[i] > arr[j]) 
            {
                count++;
            }
        }
    }
    return count;
}
----------------------------------------------------------------------------------------------
Q17) Best time to buy and Sell stock
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution							//gfg practice:- efficient
{
public:
    //Function to find the days of buying and selling stock for max profit.
    vector<vector<int> > stockBuySell(vector<int> A, int n)
    {
        vector<vector<int>> ans;
        for(int i=1; i<n; i++)
        {
            if(A[i] > A[i-1]) ans.push_back({i-1, i});
        }
        return ans;
    }
};
----------------------------------------------------------------------------------------------
#include <iostream>				//return profit same Question (brute force)
#include <cmath>
using namespace std;

int maxProfit(int price[], int start, int end)
{
	if(start >= end) return 0;
	int profit = 0;
	
	for(int i=start; i<end; i++)
	{
	    for(int j=i+1; j<=end; j++)
	    {
	        if(price[j] > price[i])
	        {
	            int curr_profit = price[j] - price[i] 
	                          + maxProfit(price, start, i-1)
	                          + maxProfit(price, j+1, end);
	                       
	            profit = max(profit, curr_profit);
	        }
	    }
	}
	return profit;
}

int main() 
{
	int arr[] = {1, 5, 3, 8, 12};
	int n = 5;

    cout << maxProfit(arr, 0, n - 1);
    return 0;
}
----------------------------------------------------------------------------------------------
#include <iostream>				//return profit same Question (efficient sol)
#include <cmath>
using namespace std;

int maxProfit(int price[], int n)
{
	int profit = 0;
	for(int i=1; i<n; i++)
	{
	    if(price[i] > price[i-1])
	    {
	        profit = profit + price[i] - price[i-1];
	    }
	}
	return profit;
}

int main() 
{
	int arr[] = {1, 5, 3, 8, 12};
	int n = 5;

    cout << maxProfit(arr, n);
    return 0;
}
----------------------------------------------------------------------------------------------
Q18) find all pairs on integer array whose sum is equal to given number
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//brute force
{   
public:
    int getPairsCount(int arr[], int n, int k) 
    {
        int count = 0;
        for(int i=0; i<n-1; i++)
        {
            for(int j=i+1; j<n; j++)
            {
                if(arr[i] + arr[j] == k) count++;
            }
        }
        return count;
    }
};
----------------------------------------------------------------------------------------------
class Solution								//efficient sol
{   
public:
    int getPairsCount(int arr[], int n, int k) 
    {
        int count = 0;
        unordered_map<int, int> mp;
        for(int i=0; i<n; i++)
        {
            int b = k - arr[i];
            if(mp[b])
            {
                count = count + mp[b];
            }
            mp[arr[i]]++;
        }
        return count;
    }
};
----------------------------------------------------------------------------------------------
Q19) Common elements from 3 arrays in sorted order       		 //same Q11 in matrix
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vector <int> commonElements (int A[], int B[], int C[], int n1, int n2, int n3)
{
           int i=0 ,j=0, k=0;
           vector<int> v;
           set<int> s;
           while(i<n1 && j<n2 && k<n3)
           {
               if(A[i]==B[j] && B[j]==C[k])
               {
                   //v.push_back(A[i]);
                   s.insert(A[i]);
                   i++;
                   j++;
                   k++;
               }
               else
               {
                   if(A[i] < B[j]) i++;
                   else if(B[j] < C[k]) j++;
                   else k++;
               }
           }
           for(int i:s)
           {
               v.push_back(i);
           }
           return v;
}
-------------------------------------------------------------------------------------------------
Q20)	Rearrange the array in alternating positive and negative items with O(1) extra space
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 								//Leetcode
{
public:
    vector<int> rearrangeArray(vector<int>& arr) 
    {
        int n = arr.size();
        vector<int> v(n);
        int pi=0, ni=1;
        for(int i=0; i<n; i++)
        {
            if(arr[i] > 0) 
            {
                v[pi] = arr[i];
                pi = pi+2;
            }
            else
            {
                v[ni] = arr[i];
                ni = ni+2;
            } 
        }
        return v;
    }
};
-------------------------------------------------------------------------------------------------
class Solution								//gfg practice
{
public:

	void rearrange(int arr[], int n) 
	{
	    queue<int> pi, ni;
	    for(int i=0; i<n; i++)
	    {
	        if(arr[i] >= 0) pi.push(arr[i]);
	        else ni.push(arr[i]);
	    }
	    
	    int k=0;
	    while(!pi.empty() && !ni.empty())
	    {
	        arr[k++] = pi.front();
	        pi.pop();
	        arr[k++] = ni.front();
	        ni.pop();
	    }
	    
	    while(!pi.empty())
	    {
	        arr[k++] = pi.front();
	        pi.pop();
	    }
	    
	    while(!ni.empty())
	    {
	        arr[k++] = ni.front();
	        ni.pop();
	    }
	}
};
-------------------------------------------------------------------------------------------------
Q21) Find if there is any subarray with sum equal to 0
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//brute force
{
    public:
    //Complete this function
    //Function to check whether there is a subarray present with 0-sum or not.
    bool subArrayExists(int arr[], int n)
    {
        int f = 0;
        for(int i=0; i<n; i++)
        {
            int  sum = 0;
            for(int j=i; j<n; j++)
            {
                sum = sum+arr[j];
                if(sum == 0) f = 1;
            }
            if(f == 1) break;
        }
        return f;
    }
};
-------------------------------------------------------------------------------------------------
class Solution								//efficient sol
{
    public:
    //Complete this function
    //Function to check whether there is a subarray present with 0-sum or not.
    bool subArrayExists(int arr[], int n)
    {
        int sum = 0;
        bool f = 0;
        unordered_map<int, int> mp;
        for(int i=0; i<n; i++)
        {
            sum = sum + arr[i];
            if(sum == 0 or arr[i] == 0 or mp[sum])
            {
                f = 1;
                break;
            }
            else
            {
                mp[sum] = 1;
            }
        }
        return f;
    }
};
-------------------------------------------------------------------------------------------------
Q22) Factorials of large numbers
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 							//gfg practice efficient sol
{
public:
    vector<int> factorial(int N)
    {
        vector<int> v;
        if(N == 0) return v;
        
        v.push_back(1);
        int carry = 0;
        
        for(int i=2; i<=N; i++)
        {
            for(int j=0; j<v.size(); j++)
            {
                int prod = v[j]*i + carry;
                v[j] = prod % 10;
                carry = prod / 10;
            }
            
            while(carry > 0)
            {
                v.push_back(carry % 10);
                carry = carry / 10;
            }
        }
        
        reverse(v.begin(), v.end());
        return v;
    }
};
-------------------------------------------------------------------------------------------------
Q23) Maximum Product Subarray
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 							        //Leetcode brute force
{
public:
    int maxProduct(vector<int>& arr) 
    {
        
        int n = arr.size();
        int maxp = INT_MIN;
        for(int i=0; i<n; i++)
        {
            int pro = 1;
            for(int j=i; j<n; j++)
            {
                
                pro = pro * arr[j];
                maxp = max(maxp, pro);
            }
        }
        return maxp;
    }
};
-------------------------------------------------------------------------------------------------
class Solution 								//Leetcode efficient sol
{
public:
    int maxProduct(vector<int>& arr) 
    {
        int n = arr.size();
        int maxp = INT_MIN;
        
        int pro = 1;
        for(int i=0; i<n; i++)
        {
            pro = pro * arr[i];
            maxp = max(maxp, pro);
            if(pro == 0) pro = 1;
        }
        
        pro = 1;
        for(int i=n-1; i>=0; i--)
        {
            pro = pro * arr[i];
            maxp = max(maxp, pro);
            if(pro == 0) pro = 1;
        }
        return maxp;
    }
};
-------------------------------------------------------------------------------------------------
Q24) House robber
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 							//Leetcode efficient sol
{
public:
    int rob(vector<int>& arr) 
    {
        int n = arr.size();
        if(n == 1) return arr[0];
        vector<int> v(n);
        v[0] = arr[0];
        v[1] = max(arr[0], arr[1]);
        
        for(int i=2; i<n; i++)
        {
            v[i] = max(v[i-2] + arr[i], v[i-1]);
        }
        return v[n-1];
    }
};
-------------------------------------------------------------------------------------------------
Q25) Longest Consecutive Sequence
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 						//Leetcode efficient sol
{
public:
    int longestConsecutive(vector<int>& arr) 
    {
        int n = arr.size();
        unordered_set<int> s;
        for(int i=0; i<n; i++)
            s.insert(arr[i]);
        
        int ans = 0;
        for(int i=0; i<n; i++)
        {
            if(s.find(arr[i]-1) != s.end()) continue;
            else
            {
                int count = 0;
                int curr = arr[i];
                while(s.find(curr) != s.end())
                {
                    count++;
                    curr++;
                }
                ans = max(ans, count);
            }
        }
        return ans;
    }
};
-------------------------------------------------------------------------------------------------
Q26-I) Majority Element II
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 						//Leetcode efficient sol
{
public:
    vector<int> majorityElement(vector<int>& arr) 
    {
        int n = arr.size();
        int x = n/3;
        unordered_map<int,int> m;		//we can use map instead of unordered_map
        for(int i=0; i<n; i++)
            m[arr[i]]++;
        
        vector<int> v;
        for(auto i : m)
        {
            if(i.second > x)
                v.push_back(i.first);
        }
        return v;
    }
};
-------------------------------------------------------------------------------------------------
Q26-II) Count More than n/k Occurences
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution							//gfg practice
{
    public:
    //Function to find all elements in array that appear more than n/k times.
    int countOccurence(int arr[], int n, int k) 
    {
        int x = n/k;
        unordered_map<int,int> m;		//we can use map instead of unordered_map
        for(int i=0; i<n; i++)
            m[arr[i]]++;
        
        int count = 0;
        for(auto i : m)
        {
            if(i.second > x)
                count++;
        }
        return count;
    }
};
-------------------------------------------------------------------------------------------------
Q27) Find whether an array is a subset of another array
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
string isSubset(int a1[], int a2[], int n, int m) 		//gfg practice brute force
{
    sort(a1, a1+n);
    sort(a2, a2+m);
    int count = 0;
    if(m > n) return "No";
    else
    {
        for(int i=0; i<m; i++)
        {
            for(int j=0; j<n; j++)
            {
                if(a2[i] == a1[j])
                {
                    i++;
                    count++;
                }
            }
        }
        
        if(count >= m) return "Yes";
        else return "No";
    }
}
-------------------------------------------------------------------------------------------------
string isSubset(int a1[], int a2[], int n, int m)              //gfg practice efficient sol
{
    unordered_map<int,int> m1, m2;
    for(int i=0; i<n; i++)
        m1[a1[i]]++;
        
    for(int j=0; j<m; j++)
        m2[a2[j]]++;
      
    int count = 0;  
    for(auto it=m2.begin(); it!=m2.end(); it++)
    {
        if(m1[it->first] >= it->second)
            count++;
    }
    
    if(count == m) return "Yes";
    else return "No";
}
-------------------------------------------------------------------------------------------------
Q28) Find the triplet that sum to a given value
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""		
class Solution							//gfg practice brute force
{
    public:
    //Function to find if there exists a triplet in the 
    //array A[] which sums up to X.
    bool find3Numbers(int A[], int n, int X)
    {
        bool f = 0;
        for(int i=0; i<n-2; i++)
        {
            for(int j=i+1; j<n-1; j++)
            {
                for(int k=j+1; k<n; k++)
                {
                    if(A[i] + A[j] + A[k] == X)
                    {
                        f = 1;
                        break;
                    }
                }
            }
        }
        return f;
    }
};
-------------------------------------------------------------------------------------------------
class Solution							//gfg practice efficient sol
{
    public:
    //Function to find if there exists a triplet in the 
    //array A[] which sums up to X.
    bool find3Numbers(int A[], int n, int X)
    {
        sort(A, A + n);
    
        for (int i=0; i<n-2; i++) 
        {
            int l = i + 1; 
            int r = n - 1; 
            while (l < r) 
            {
                if (A[i] + A[l] + A[r] == X) return true;
                else if (A[i] + A[l] + A[r] < X) l++;
                else r--;
            }
        }
        return false;
    }
};
-------------------------------------------------------------------------------------------------
class Solution                 //sum = 0     			//Leetcode efficient sol
{
public:
    vector<vector<int>> threeSum(vector<int>& arr) 
    {
        vector<vector<int>>ans;
        int n = arr.size();
        sort(arr.begin(), arr.end());

        for(int i=0; i<n; i++) 
        {
            int target = 0 - arr[i];            //arr[i] + arr[l] + arr[r] = sum
            int l = i + 1;
            int r = n - 1;

            while(l < r) 
            {
                int sum = arr[l] + arr[r];

                if(sum < target) l++;
                else if(sum > target) r--;
                else 
                {
                    int x = arr[l];
                    int y = arr[r];
                    ans.push_back({arr[i], arr[l], arr[r]});
                
                    while(l < r && arr[l] == x) l++;
                    while(l < r && arr[r] == y) r--;                        
                }
            }

            // Ensuring that we don't encounter duplicate values for arr[i].
            while (i + 1 < n && arr[i] == arr[i+1]) 
                i++;
        
        }
        return ans;
    }
};
-------------------------------------------------------------------------------------------------
Q29) Chocolate Distribution Problem
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution							//gfg practice efficient sol
{
    public:
    long long findMinDiff(vector<long long> arr, long long n, long long m)
    {
        sort(arr.begin(), arr.end());
        long long ans = LONG_LONG_MAX;
        
        for(int i=0; i+m-1<n; i++)
        {
            long long currM = arr[i+m-1] - arr[i];
            ans = min(ans, currM);
        }
        return ans;
    }   
};
-------------------------------------------------------------------------------------------------
Q30) Smallest Subarray with sum greater than a given value
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 								//Leetcode brute force
{
public:
    int minSubArrayLen(int x, vector<int>& arr) 
    {
        int n = arr.size();
        int ans = INT_MAX;
        for(int i=0; i<n; i++)
        {
            int sum = 0;
            for(int j=i; j<n; j++)
            {
                sum = sum + arr[j];
                if(sum >= x)
                {
                    ans = min(ans, j-i+1);
		    break;
                }
            }
        }
        if(ans == INT_MAX) ans = 0;
        return ans;
    }
};
-------------------------------------------------------------------------------------------------
class Solution 								//Leetcode efficient sol
{
public:
    int minSubArrayLen(int x, vector<int>& arr) 
    {
        int n = arr.size();
        int ans = INT_MAX;
        int left = 0;
        int sum = 0;
        for(int i=0; i<n; i++)
        {
            sum = sum + arr[i];
            while(sum >= x)
            {
                ans = min(ans, i+1-left);
                sum = sum - arr[left];
                left++;
            }
        }
        
        if(ans == INT_MAX) return 0;
        return ans;
    }
};
-------------------------------------------------------------------------------------------------
Q31) Three way partitioning of an array around a given value
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution								//gfg efficient sol
{   
public:
    void threeWayPartition(vector<int>& arr,int a, int b)
    {
        int n = arr.size();
        int l = 0; 
        int r = n-1;
        for(int i=0; i<=r; i++)
        {
            if(arr[i] < a)
            {
                swap(arr[i], arr[l]);
                l++;
            }
            if(arr[i] > b)
            {
                swap(arr[i], arr[r]);
                r--;
                i--;
            }
        }
    }
};
-------------------------------------------------------------------------------------------------
Q32) Minimum swaps required bring elements less equal K together
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution							//gfg practice efficient sol
{
public:
    int minSwap(int arr[], int n, int k) 
    {
        int good = 0;
        for(int i=0; i<n; i++)
            if(arr[i] <= k) good++;
        
        int bad = 0;
        for(int i=0; i<good; i++)
            if(arr[i] > k) bad++;
        
        int i=0, j=good, ans=bad;
        
        while(j < n)
        {
            if(arr[i] > k) bad--;
            if(arr[j] > k) bad++;
            ans = min(ans, bad);
            i++;
            j++;
        }
        return ans;
    }
};
-------------------------------------------------------------------------------------------------
Q33-I) Check if all elements of the array are palindrome or not
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution 
{
public:
    bool solve(int x)
    {
        string s = "" + to_string(x);
        int len = s.length();
        for(int i=0; i<len/2; i++)
        {
            if(s[i] != s[len-1-i]) return false;
        }
        return true;
    }
    
    bool PalinArray(int arr[], int n)
    {
    	for(int i=0; i<n; i++)
        {
            bool ans = solve(arr[i]);
            if(ans == false) return false;
        }
        return true;
    }
};
-------------------------------------------------------------------------------------------------
Q33-II) Minimum no. of operations required to make an array palindrome
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include<bits/stdc++.h>
using namespace std;

int minop(int arr[], int n)
{
    int ans = 0;
    for(int i=0, j=n-1; i<=j;)
    {
        if(arr[i] == arr[j])
        {
            i++;
            j--;
        }
        else if(arr[i] < arr[j])
        {
            i++;
            arr[i] = arr[i-1] + arr[i];
            ans++;
        }
        else
        {
            j--;
            arr[j] = arr[j] + arr[j+1];
            ans++;
        }
    }
    return ans;
}

int main()
{
    int arr[] = { 1, 14, 15, 99 };
    int n = sizeof(arr)/sizeof(arr[0]);
 
    cout << minop(arr, n);
}
-------------------------------------------------------------------------------------------------
Q34) Find the median 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution
{
public:
		int find_median(vector<int> v)
		{
		    int n = v.size();
		    sort(v.begin(), v.end());
		    int ans = 0;
		    int x = n/2;

		    if(n%2 == 0) ans = (v[x-1] + v[x]) / 2;		//n-even
		    else ans = v[x];					//n-odd

		    return ans;
		}
};
-------------------------------------------------------------------------------------------------