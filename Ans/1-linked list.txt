Q1) reverse link list
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>                       //Iterative Method 
using namespace std; 

struct Node
{
    int data;
    Node* next;
    Node(int x)
    {
        data=x;
        next=NULL;
    }
};

void printlist(Node *head)
{
    Node *curr=head;
    while(curr != NULL)
    {
        cout << curr->data << " ";
        curr = curr->next;
    }
    cout<<endl;
}

Node* reverseList(Node* head)            //  prev  10(cur) 20(next) 30 --> 10(prev) 20(cur) 30(next) --> 10 20(prev) 30(cur) next --> 10 20 30(prev) curr
{
    Node* cur=head;
    Node* prev=NULL;
    while(cur != NULL)
    {
        Node* next = cur->next;
        cur->next = prev;
        prev = cur;
        cur = next;
    }
    return prev;
}

int main() 
{ 
	Node *head = new Node(10);
	head->next=new Node(20);
	head->next->next=new Node(30);
	printlist(head);
	
	head=reverseList(head);
	printlist(head);
	return 0;
} 
----------------------------------------------------------------------------------
Node* reverseList(Node* head) 				//Recursive Method 
{
    if(head == NULL || head->next == NULL){return head;}
    Node * newhead = reverseList(head->next);
    head->next->next = head;
    head->next = NULL;
    return newhead;
}
----------------------------------------------------------------------------------
Q2)Reverse a Linked List in groups of given size k
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h> 				//Recursive method
using namespace std; 

struct Node
{
    int data;
    Node* next;
    Node(int x)
    {
        data=x;
        next=NULL;
    }
};

void printlist(Node *head)
{
    while(head != NULL)
    {
        cout << head->data << " ";
        head = head->next;
    }
    cout<<endl;
}

Node *reverseK(Node *head,int k)
{
    Node *curr = head, *next = NULL, *prev = NULL;
    int count=0;
    
    while(curr != NULL && count < k)
    {
        next=curr->next;
        curr->next=prev;
        prev=curr;
        curr=next;
        count++;
    }
    
    if(next != NULL)
    {
        Node *rest_head=reverseK(next,k);
        head->next=rest_head;
    }
    return prev;
}

int main() 
{ 
	Node *head=new Node(10);
	head->next=new Node(20);
	head->next->next=new Node(30);
	head->next->next->next=new Node(40);
	head->next->next->next->next=new Node(50);
	head->next->next->next->next->next=new Node(60);
	head->next->next->next->next->next->next=new Node(70);
	printlist(head);
	
	head=reverseK(head,3);
	printlist(head);
	return 0;
} 
----------------------------------------------------------------------------------
Node *reverseK(Node *head, int k)			//Iterative method
{
    Node *curr = head, *prevfirst = NULL;
    bool isfirstpass = true;
    while(curr != NULL)
    {
        Node *first = curr, *prev = NULL;
        int count = 0;
        while(curr != NULL && count < k)
        {
            Node *next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
            count++;
        }
        if(isfirstpass)
        {
            head = prev;
            isfirstpass = false;
        }
        else
        {
            prevfirst->next = prev;
        }
        prevfirst = first;
    }
    return head;
}
----------------------------------------------------------------------------------
Q3)Detect loop in link list
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
bool detectLoop(Node* head)
{
        if(!head) return false;
        Node *slow = head, *fast = head;
        while(fast && fast->next)
        {
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast)return true;
        }
        return false;
}
---------------------------------------------------------------------------------
#include <bits/stdc++.h> 		//Changes Pointers
using namespace std; 

struct Node
{
    int data;
    Node* next;
    Node(int x)
    {
        data=x;
        next=NULL;
    }
};

bool isLoop(Node* head) 
{   
    Node* temp=new Node(0);
    Node *curr=head, *curr_next = NULL;
    while (curr != NULL) 
    {  
        if (curr->next == NULL)return false;
        if(curr->next == temp)return true;
        
        curr_next=curr->next;
        curr->next=temp;
        curr=curr_next;
    } 
    return false; 
}

int main() 
{ 
	Node *head=new Node(15);
	head->next=new Node(10);
	head->next->next=new Node(12);
	head->next->next->next=new Node(20);
	head->next->next->next->next=head->next;
	
	if (isLoop(head)) 
           cout << "Loop found"; 
        else
           cout << "No Loop"; 
	return 0;
} 
----------------------------------------------------------------------------------
			                                     //Hashing method
// Returns true if there is a loop in linked list
// else returns false.
bool isLoop(Node* head)
{
    unordered_set<Node*> s;

    while (head != NULL) 
    {
        // If we are seeing the node for the first time, insert it in hash

        if (s.find(head) == s.end())
            s.insert(head);
           
 
        // If this node is already present in hashmap it means there is a cycle
        // (Because you will be encountering the node for the second time).
        else
             return true;
 
        head = head->next;
    }
 
    return false;
}
---------------------------------------------------------------------------------
Q4)Detect and remove loop from link list
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution							//gfg practice
{
    public:
    //Function to remove a loop in the linked list.
    void removeLoop(Node* head)
    {
        Node *curr = head;
        while(curr->next > curr && curr)
        {
            curr = curr->next;
        }
        curr->next = NULL;
    }
};
--------------------------------------------------------------------------------
class Solution							//gfg practice
{
    public:
    //Function to remove a loop in the linked list.
    void removeLoop(Node* head)
    {
        Node *slow = head;
        Node *fast = head;
        while(fast && fast->next)
        {
            slow = slow->next;
            fast = fast->next->next;
            if(slow == fast) break;
        }
        if(slow != fast) return;
        slow = head;
        while(slow != fast)
        {
            slow = slow->next;
            fast = fast->next;
        }
        while(slow->next !=fast)
        {
            slow=slow->next;
        }
        slow->next=nullptr;
    }
};
---------------------------------------------------------------------------------
Q5) find starting point of loop in link list
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>
using namespace std;

struct Node
{
    int data;
    Node* next;
    Node(int x)
    {
        data=x;
        next=NULL;
    }
};

Node* detect_starting_point_Loop(Node* head)
{
    if (head == NULL || head->next == NULL)return NULL;
    Node *slow = head, *fast = head;

	while (fast != NULL && fast->next != NULL) 
	{
        	slow = slow->next;
		fast = fast->next->next;
		if (slow == fast)break;
	}
	// If loop does not exist
	if (slow != fast)return NULL;
	
	// If loop exists. Start slow from
	// head and fast from meeting point.
	slow = head;
	while (slow != fast) 
	{
		slow = slow->next;
		fast = fast->next;
	}
	return slow;    //we can also use fast instead of slow
}

/* Driver program to test above function*/
int main()
{
	Node* head = new Node(50);
	head->next = new Node(20);
	head->next->next = new Node(15);
	head->next->next->next = new Node(4);
	head->next->next->next->next = new Node(10);

	/* Create a loop for testing */
	head->next->next->next->next->next = head->next;

	Node* res = detect_starting_point_Loop(head);
	if (res == NULL)
		cout << "Loop does not exist";
	else
		cout << "Loop starting node is " << res->data;
	return 0;
}
---------------------------------------------------------------------------------
Q6) Remove duplicates from sorted link list
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <iostream>
using namespace std;

struct Node
{
    int data;
    Node* next;
    Node(int x)
    {
        data=x;
        next=NULL;
    }
};

void printlist(Node *head)
{
    while(head != NULL)
    {
        cout << head->data << " ";
        head = head->next;
    }
    cout<<endl;
}

Node *removeDuplicates(Node *head)
{
        Node *curr = head;
        if(curr == NULL) return NULL;
        while(curr->next != NULL)
        {
            if(curr->data == curr->next->data)
            {
                Node *temp = curr->next;
                curr->next = curr->next->next;
                delete(temp);
            }
            else
            {
                curr = curr->next;
            }
        }
        return head;
}

int main()
{
	Node* head = new Node(50);
	head->next = new Node(20);
	head->next->next = new Node(20);
	head->next->next->next = new Node(4);
	head->next->next->next->next = new Node(4);
	
	printlist(head);
        head = removeDuplicates(head);
	printlist(head);
	return 0;
}
---------------------------------------------------------------------------------
Q7) Remove duplicates from unsorted link list
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Node* removeDuplicates(Node* head)
{
    // Hash to store seen values
    unordered_set<int> s;
 
    /* Pick elements one by one */
    Node* curr = head;
    Node* prev = NULL;

    while (curr != NULL) 
    {
        // If current value is not seen before
        if (s.find(curr->data) == s.end())      //s.end() means iterator to beyond the last ele.
        {
            s.insert(curr->data);
            prev = curr;
        }

        else // If current value is seen before
        {
            prev->next = curr->next;
            delete (curr);
        }
        curr = prev->next;
    }
    return head;
}
---------------------------------------------------------------------------------
Q8) Write a Program to Move the last element to Front in a Linked List.
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>
using namespace std;

struct Node
{
    int data;
    Node* next;
    Node(int x)
    {
        data=x;
        next=NULL;
    }
};

void printlist(Node *head)
{
    while(head != NULL)
    {
        cout << head->data << " ";
        head = head->next;
    }
    cout<<endl;
}

Node* movelast_to_front(Node *head)
{
    Node *temp = head;
    while(temp->next->next != NULL)
    {
        temp = temp->next;
    }
    Node* seclast = temp;
    Node* last = temp->next;
    
    last->next = head;
    seclast->next = NULL;
    head = last;            //last becomes head
    return head;
}

int main()
{
	Node* head = new Node(50);
	head->next = new Node(20);
	head->next->next = new Node(25);
	head->next->next->next = new Node(4);
	head->next->next->next->next = new Node(45);
	
	printlist(head);
        head = movelast_to_front(head);
	printlist(head);
	return 0;
}
---------------------------------------------------------------------------------
Q9) find intersection of two sorted link list
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>
using namespace std;

struct Node
{
    int data;
    Node* next;
    Node(int x)
    {
        data=x;
        next=NULL;
    }
};

void printlist(Node *head)
{
    while(head != NULL)
    {
        cout << head->data << " ";
        head = head->next;
    }
    cout<<endl;
}

Node* findIntersection(Node* head1, Node* head2)
{
    Node* ptr1 = head1;
    Node* ptr2 = head2;
    Node* head = NULL;
    Node* curr = NULL;
    
    while(ptr1 != NULL && ptr2 != NULL)
    {
        if(ptr1->data == ptr2->data)
        {
            if(head == NULL)
            {
                Node* t = new Node(ptr1->data);
                head = t;
                curr = t;
            }
            else
            {
                Node* t = new Node(ptr1->data);
                curr->next = t;
                curr = curr->next;
            }
            ptr1 = ptr1->next;
            ptr2 = ptr2->next;
        }
        
        else
        {
            if(ptr1->data < ptr2->data)
                ptr1 = ptr1->next;
                
            else
                ptr2 = ptr2->next;
        }
    }
    return head;
}

int main()
{
	Node* head1 = new Node(10);                     //ll_1 = 10 20 30 40 50 
	head1->next = new Node(20);
	head1->next->next = new Node(30);
	head1->next->next->next = new Node(40);
	head1->next->next->next->next = new Node(50);
	
	Node* head2 = new Node(20);                     //ll_2 = 20 40 60 80
	head2->next = new Node(40);
	head2->next->next = new Node(60);
	head2->next->next->next = new Node(80);
	
	printlist(head1);
	printlist(head2);
	
    	Node* head = findIntersection(head1, head2);    //com_ll = 20 40
	printlist(head);
	return 0;
}
---------------------------------------------------------------------------------

Q10) Merge sort for link list
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>
using namespace std;

struct Node					//struct
{
    int data;
    Node* next;
    
    Node(int x)
    {
        data=x;
        next=NULL;
    }
};

void printlist(Node *head)			//printlist
{
    while(head != NULL)
    {
        cout << head->data << " ";
        head = head->next;
    }
    cout<<endl;
}

Node *merge(Node *a, Node *b)			//merge function
{
        if(a == NULL) return b;
        if(b == NULL) return a;
       
        Node *head = NULL, *tail = NULL;
       
        if(a->data <= b->data)
        {
            head = a;
            tail = a;
            a = a->next;
        }
        else
        {
            head = b;
            tail = b;
            b = b->next;
        }
       
       
        while(a != NULL && b != NULL)
        {
            if(a->data <= b->data)
            {
                tail->next = a;
                tail = a;
                a = a->next;
            }
            else
            {
                tail->next = b;
                tail = b;
                b = b->next;
            }
           
        }
        if(a == NULL)
        {
            tail->next = b;
        }
        else
        {
            tail->next = a;
        }
       
        return head;
}

Node* middle(Node* head)			//find middle
{
    Node* slow = head;
    Node* fast = head->next;
    
    while(fast && fast->next)
    {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}

Node* mergesort(Node* head)			//mergesort function
{
    if(head == NULL || head->next == NULL)
	return head;
    
    Node* left = head;
    Node* mid = middle(head);
    Node* right = mid->next;
    mid->next = NULL;
    
    left = mergesort(left);
    right = mergesort(right);
    Node* ans = merge(left, right);
    
    return ans;
}

int main()					//main function
{
	Node* head = new Node(10);                    
	head->next = new Node(20);
	head->next->next = new Node(15);
	head->next->next->next = new Node(60);
	head->next->next->next->next = new Node(40);
	
    	printlist(head);
    
    	Node* new_head = mergesort(head);
	printlist(new_head);
	return 0;
}
---------------------------------------------------------------------------------
Q11)find middle element of link list
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <iostream>
using namespace std;

struct Node
{
    int data;
    Node* next;
    
    Node(int x)
    {
        data=x;
        next=NULL;
    }
};

void printlist(Node *head)
{
    while(head != NULL)
    {
        cout << head->data << " ";
        head = head->next;
    }
    cout<<endl;
}

Node* middleNode(Node* head) 
{
    //n=6, fast = head          --->   mid = 40 
    //     fast = head->next    --->   mid = 30

    Node *slow = head, *fast = head;    
    while(fast && fast->next)
    {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}

int main()
{
	Node* head = new Node(10);                    
	head->next = new Node(20);
	head->next->next = new Node(30);
	head->next->next->next = new Node(40);
	head->next->next->next->next = new Node(50);
	head->next->next->next->next->next = new Node(60);
    	printlist(head);
    
	Node* mid = middleNode(head);
	cout << mid->data;
	
	return 0;
}
---------------------------------------------------------------------------------
Q12.A) find Intersection Point in Y Shapped "sorted Linked Lists" 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
//Function to find intersection point in Y shaped Linked Lists.
int intersectPoint(Node* head1, Node* head2)
{
    Node *ptr1 = head1, *ptr2 = head2;
    while(ptr1 && ptr2)
    {
        if(ptr1->data == ptr2->data)
        {
            return ptr1->data;
        }
        else
        {
            if(ptr1->data < ptr2->data)
                ptr1 = ptr1->next;
            else 
                ptr2 = ptr2->next;
        }
    }
}
---------------------------------------------------------------------------------
Q12.B) find Intersection Point in Y Shapped Linked Lists 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
int intersectPoint(Node* head1, Node* head2)		//pointers method
{
    Node *temp1 = head1, *temp2 = head2;
    int l1 = 0, l2 = 0;
    
    while(temp1)
    {
        temp1 = temp1->next;
        l1++;
    }
    
    while(temp2)
    {
        temp2 = temp2->next;
        l2++;
    }
    
    int d = 0;

    if(l1>l2)
    {
        d = l1 - l2;
        temp1 = head1;
        temp2 = head2;
    }
    
    else if(l2>l1)
    {
        d = l2 - l1;
        temp1 = head2;
        temp2 = head1;
    }
    
    else
    {
        d = 0;
        temp1 = head1;
        temp2 = head2;
    }
    
    for(int i=0; i<d; i++)
    {
        temp1 = temp1->next;
    }
    
    while(temp1 != temp2)
    {
        temp1 = temp1->next;
        temp2 = temp2->next;
    }
    return temp1->data;
}
---------------------------------------------------------------------------------
#include <bits/stdc++.h>			//hashing method
using namespace std;

struct Node
{
    int data;
    Node* next;
    
    Node(int x)
    {
        data=x;
        next=NULL;
    }
};

void printlist(Node *head)
{
    while(head != NULL)
    {
        cout << head->data << " ";
        head = head->next;
    }
    cout<<endl;
}

// function to find the intersection point of two lists
void MegeNode(Node* head1, Node* head2)
{
    unordered_set<Node*> s;
    while(head1)
    {
        s.insert(head1);
        head1 = head1->next;
    }
    
    while(head2)
    {
        if(s.find(head2) != s.end())
        {
            return head2->data;
            break;
        }
        else
        {
            head2 = head2->next;
        }
    }
}

int main()
{
	// list 1                               1 2 3 4 5 6 7
	Node* head1 = new Node(1);
	head1->next = new Node(2);
	head1->next->next = new Node(3);
	head1->next->next->next = new Node(4);
	head1->next->next->next->next = new Node(5);
	head1->next->next->next->next->next = new Node(6);
    	head1->next->next->next->next->next->next = new Node(7);
	
	// list 2                               10 9 8 4 5 6 7 
	Node* head2 = new Node(10);
	head2->next = new Node(9);
	head2->next->next = new Node(8);
	head2->next->next->next = head1->next->next->next;
	

	printlist(head1);
	printlist(head2);
		
	MegeNode(head1,head2);
	
	return 0;
}
---------------------------------------------------------------------------------
Q13) Quick sort for link list
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <iostream>
using namespace std;

struct Node
{
    int data;
    Node* next;
    
    Node(int x)
    {
        data=x;
        next=NULL;
    }
};

void printlist(Node *head)
{
    while(head != NULL)
    {
        cout << head->data << " ";
        head = head->next;
    }
    cout<<endl;
}
    
void SwapValue(Node* a, Node* b)
{
    int temp = a->data;
    a->data = b->data;
    b->data = temp;
}
    
Node* Partition(Node* start, Node* end)
{
    int pivotValue = start->data;
    Node* p = start;
    Node* q = start->next;
    while(q != end)
    {
        if (q->data < pivotValue)
        {
            p = p->next;
            SwapValue(p,q);
        }
        else
        {
            q = q->next;
        }
    }
    SwapValue(p,start);
    return p;
}
        
        
void QuickSort(Node* start, Node* end)
{
        if (start != end)
        {
            Node* mid =Partition(start, end);
            QuickSort(start, mid);
            QuickSort(mid->next, end);
        }
       //return start; 
}
        
    
Node* sortList(Node* head) 
{
        QuickSort(head,NULL);
        return head;
}

int main()
{
	Node* head = new Node(10);                    
	head->next = new Node(20);
	head->next->next = new Node(15);
	head->next->next->next = new Node(60);
	head->next->next->next->next = new Node(40);
	
    	printlist(head);
    
	Node* n_head = sortList(head);
	printlist(n_head);
	return 0;
}
---------------------------------------------------------------------------------
Q14) Check if circular linked list or not
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
bool isCircular(Node *head)
{
    Node *curr = head;
    
    while(curr)
    {
    
        if(curr->next == head)
            return true;
            
        curr = curr->next;
    }
    
    return false;
}
---------------------------------------------------------------------------------
Q15) split a circular linked list into two halves
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
//  function which splits the circular linked list.  head is pointer
// to head Node of given lined list.  head1_ref1 and *head_ref2
// are pointers to head pointers of resultant two halves.

void splitList(Node *head, Node **head1_ref, Node **head2_ref)
{
    Node *slow = head, *fast = head;
    
    while(fast->next != head && fast->next->next != head)
    {
        slow = slow->next;
        fast = fast->next->next;
    }
    
    *head1_ref = head;
    *head2_ref = slow->next;
    
    slow->next = head;
    
    if(fast->next == head) 
        fast->next = *head2_ref;
        
    else
        fast->next->next = *head2_ref;
}
---------------------------------------------------------------------------------
Q16) Check if Linked List is Palindrome
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution
{
public:
  
int length(Node *head)                //length function
{
    Node *curr = head;
    int n=0;
    while(curr)
    {
        n++;
        curr = curr->next;
    }
    return n;
}

Node *reverse(Node *head)              //reverse function
{
    Node *curr = head, *prev = NULL, *next;
    while(curr)
    {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}
    
bool isPalindrome(Node *head)           //ispalindrome function
{
   int mid = length(head)/2 - 1;	//5->4->3->2->3->4->5
   Node *curr = head;
   
   while(curr && mid > 0)
   {
       mid--;
       curr = curr->next;
   }
   
   Node *reversehead = reverse(curr);
   
   int ld = length(head);			//ld = 3
   curr = head;
   while(curr && reversehead && ld > 0)
   {
       if(curr->data != reversehead->data) 
       {
           return false;
       }
       else
       {
           curr = curr->next;
           reversehead = reversehead->next;
           ld--;
       }
   }
   
   if(ld == 0)return true;
   return false;
}
};
---------------------------------------------------------------------------------
Q17) Delete a given node from linked list
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
void deleteNode(Node *node)
{
    Node *curr = node->next;
    node->data = curr->data;
    node->next = curr->next;
    delete(curr);
}

int main() 
{ 
	Node *head=new Node(4);
	Node *node=new Node(5);
	head->next=node;
	head->next->next=new Node(1);
	head->next->next->next=new Node(9);
	
	printlist(head);
	deleteNode(node);
	printlist(head);
	return 0;
} 
---------------------------------------------------------------------------------
Q17.A) Delete head of linked list
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Node* deleteNode(Node *head)
{
    if(head == NULL)return NULL;
    else
    {
        Node *curr = head->next;
        delete(head);
        return curr;
    }
}

int main() 
{ 
	Node *head=new Node(4);
	head->next=new Node(5);
	head->next->next=new Node(1);
	head->next->next->next=new Node(9);
	
	printlist(head);
	Node *new_head = deleteNode(head);
	printlist(new_head);
	return 0;
} 
---------------------------------------------------------------------------------
Q17.B) Delete tail of linked list
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Node* deleteNode(Node *head)
{
    if(head == NULL)return NULL;
    if(head->next == NULL)
    {
        delete(head);
        return NULL;
    }
    
    Node *curr = head;
    while(curr->next->next)
    {
        curr = curr->next;
    }
    delete(curr->next);
    curr->next = NULL;
    return head;
}

int main() 
{ 
	Node *head=new Node(4);
	head->next=new Node(5);
	head->next->next=new Node(1);
	head->next->next->next=new Node(9);
	
	printlist(head);
	Node *new_head = deleteNode(head);
	printlist(new_head);
	return 0;
} 
---------------------------------------------------------------------------------
Q18) Delete a given node from circular linked list
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Node *deleteHead(Node *head)
{
    if(head == NULL)return NULL;
    if(head->next == head)
    {
        delete head;
        return NULL;
    }
    
    Node *curr = head->next;
    head->data = curr->data;
    head->next = curr->next;
    delete curr;
    return head;
}

Node *deleteKth(Node *head,int k)
{
    if(head == NULL)return head;
    
    if(k == 1)return deleteHead(head);
    
    Node *curr=head;
    for(int i=0; i<k-2; i++)
    {
        curr=curr->next;
    }
    
    Node *temp=curr->next;
    curr->next=curr->next->next;
    delete temp;
    return head;
}

int main() 
{ 
	Node *head=new Node(10);
	head->next=new Node(20);
	head->next->next=new Node(30);
	head->next->next->next=new Node(40);
	head->next->next->next->next=head;
	head=deleteKth(head,2);
	printlist(head);
	return 0;
} 
---------------------------------------------------------------------------------
Q19) Reverse a doubly linked list
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
struct Node* reverseDLL(struct Node * head)
{
    struct Node *curr = head, *prev = NULL, *next;
    while(curr)
    {
        next = curr->next;
        curr->next = prev;
        curr->prev = next;
        prev = curr;
        curr = next;
    }
    return prev;
}
---------------------------------------------------------------------------------
			Doubly linked list
                        """"""""""""""""""
#include <bits/stdc++.h> 
using namespace std; 

struct Node
{
    int data;
    Node* prev;
    Node* next;
    Node(int x)
    {
        data=x;
        prev=NULL;
        next=NULL;
    }
};

void printlist(Node *head)
{
    while(head != NULL)
    {
        cout << head->data << " ";
        head = head->next;
    }
    cout<<endl;
}

int main() 
{ 
	Node *head=new Node(10);
	Node *temp1=new Node(20);
	Node *temp2=new Node(30);
	head->next=temp1;
	temp1->prev=head;
	temp1->next=temp2;
	temp2->prev=temp1;
	printlist(head);
	return 0;
} 
---------------------------------------------------------------------------------
Q20) find pair whose sum equal to given value x
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h> 
using namespace std; 

struct Node
{
	int data;
	Node *next, *prev;
};

void printlist(Node *head)
{
    while(head != NULL)
    {
        cout << head->data << " ";
        head = head->next;
    }
    cout<<endl;
}

// Function to find pair whose sum equal to given value x.
void pairSum(Node *head, int x)
{
	Node *ptr1 = head;
	Node *ptr2 = head;
	
	while (ptr2->next != NULL)
	{
		ptr2 = ptr2->next;
	}
	
	bool found = false;

	while (ptr1 != ptr2 && ptr2->next != ptr1)
	{
		if ((ptr1->data + ptr2->data) == x)
		{
			found = true;
			cout << "(" << ptr1->data<< ", " << ptr2->data << ")" << endl;

			ptr1 = ptr1->next;
			ptr2 = ptr2->prev;
		}
		else
		{
			if ((ptr1->data + ptr2->data) < x)
				ptr1 = ptr1->next;
			else
				ptr2 = ptr2->prev;
		}
	}

	if (found == false)
		cout << "No pair found";
}

void insert(Node **head, int x)
{
	Node *temp = new Node;
	temp->data = x;
	temp->next = temp->prev = NULL;
	
	if ((*head) == NULL)
	{
		*head = temp;
	}
	else
	{
		temp->next = *head;
		(*head)->prev = temp;
		*head = temp;
	}
}

int main()
{
	Node *head = NULL;
	insert(&head, 9);
	insert(&head, 8);
	insert(&head, 6);
	insert(&head, 5);
	insert(&head, 4);
	insert(&head, 2);
	insert(&head, 1);
	
	
    	printlist(head);
    	int x = 7;
	pairSum(head, x);

	return 0;
}
---------------------------------------------------------------------------------
Q21) Count triplets in a sorted doubly linked list whose sum is equal to a given value x
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
int countTriplets(Node* head, int x)
{
    Node *ptr1, *ptr2, *ptr3;
    int count = 0;
 
    for (ptr1 = head; ptr1 != NULL; ptr1 = ptr1->next)
        for (ptr2 = ptr1->next; ptr2 != NULL; ptr2 = ptr2->next)
            for (ptr3 = ptr2->next; ptr3 != NULL; ptr3 = ptr3->next)
 
                // if elements in the current triplet sum up to 'x'
                if ((ptr1->data + ptr2->data + ptr3->data) == x)
                    count++;
 
    return count;
}
---------------------------------------------------------------------------------
Q22) Add 1 to a number represented as linked list
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution
{
    public:
    Node *reverse(Node * head)				//reverse function
    {
        Node *curr = head, *prev, *next;
        while(curr)
        {
            next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = prev;
        }
        return prev;
    }
    
    Node* addOne(Node *head) 				//addOne function
    {
        head = reverse(head);
        bool f = true;
        Node *curr = head;
        
        while(curr && f == true)
        {
            if(curr->data == 9 && curr->next == NULL)	
            {
                curr->data = 1;
                Node *temp = new Node(0);
                temp->next = head;
                head = temp;
                curr = curr->next;
            }
            
            else if(curr->data == 9)			
            {
                curr->data = 0;
                curr = curr->next;
            }
            
            else
            {
                curr->data = curr->data + 1;
                curr = curr->next;
                f = false;
            }
        }
        head = reverse(head);
        return head;
    }
};
---------------------------------------------------------------------------------
Q23) Add two numbers represented by linked lists
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
class Solution
{
    public:
    struct Node *reverse(struct Node *head)
    {
        Node *curr = head, *prev = NULL, *next;
        while(curr)
        {
            next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
    
    struct Node* addTwoLists(struct Node* first, struct Node* second)
    {
        first = reverse(first);
        second = reverse(second);
        int s = 0, c = 0;
        Node *temp, *res = NULL, *curr = NULL;
        while(first || second)
        {
            s = c + (first?first->data:0) + (second?second->data:0);
            c = (s>=10)?1:0;
            s = s%10;
            temp = new Node(s);
            
            if(res == NULL)res = temp;
            
            else curr->next = temp;
            curr = temp;
            
            if(first) first = first->next;
            if(second) second = second->next;
        }
        
        if(c>0)
        {
            temp = new Node(c);
            curr->next = temp;
            curr = temp;
        }
        res =  reverse(res);
        return res;
    }
};
---------------------------------------------------------------------------------
Q24) Rotate Doubly linked list by N nodes
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h> 
using namespace std; 

struct Node
{
	int data;
	Node *next, *prev;
};

void printlist(Node *head)
{
    while(head != NULL)
    {
        cout << head->data << " ";
        head = head->next;
    }
    cout<<endl;
}

Node *rotatedbyN(Node *head,int n)
{
    if(n == 0)return head;

    Node *curr = head;
    int count = 1;
    while(curr && count < n)
    {
        curr = curr->next;
        count++;
    }
    Node *nth_node = curr;			
    
    while(curr->next)
    {
        curr = curr->next;
    }

    curr->next = head;
    head->prev = curr;
    head = nth_node->next;
    head->prev = NULL;
    nth_node->next = NULL;
    return head;
}

void insert(Node **head, int x)
{
	Node *temp = new Node;
	temp->data = x;
	temp->next = temp->prev = NULL;
	
	if ((*head) == NULL)
	{
		*head = temp;
	}
	else
	{
		temp->next = *head;
		(*head)->prev = temp;
		*head = temp;
	}
}

int main()
{
	Node *head = NULL;
	insert(&head, 5);
	insert(&head, 4);
	insert(&head, 3);
	insert(&head, 2);
	insert(&head, 1);

	printlist(head);
    	head = rotatedbyN(head,3);
    	printlist(head);

	return 0;
}
---------------------------------------------------------------------------------
Q25) Reverse a doubly linked list in groups of given size k.
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h> 
using namespace std; 

struct Node
{
	int data;
	Node *next, *prev;
};

void printlist(Node *head)
{
    while(head != NULL)
    {
        cout << head->data << " ";
        head = head->next;
    }
    cout<<endl;
}

Node *reverseinKsize(Node *head, int k)
{
    Node *curr = head, *prev = NULL, *next = NULL;
    int count = 0;
    while(curr && count < k)
    {
        next = curr->next;
        curr->next = prev;
        if(count < k-1)curr->prev = next;
        prev = curr;
        curr = next;
        count++;
    }
    
    if(next)
    {
        head->next = reverseinKsize(next,k);
        head->next->prev = head;
    }
    return prev;
}

void insert(Node **head, int x)
{
	Node *temp = new Node;
	temp->data = x;
	temp->next = temp->prev = NULL;
	
	if ((*head) == NULL)
	{
		*head = temp;
	}
	else
	{
		temp->next = *head;
		(*head)->prev = temp;
		*head = temp;
	}
}

int main()
{
	Node *head = NULL;
	insert(&head, 7);
	insert(&head, 6);
	insert(&head, 5);
	insert(&head, 4);
	insert(&head, 3);
	insert(&head, 2);
	insert(&head, 1);

	printlist(head);
    	head = reverseinKsize(head,2);
    	printlist(head);

	return 0;
}
---------------------------------------------------------------------------------
Q26) Can we reverse a linked list in less than O(n) ?
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Q27) Why Quicksort is preferred for. Arrays and Merge Sort for LinkedLists ?
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""	
Q28) Flattening a linked list
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
struct Node					//structure
{
	int data;
	struct Node * next;
	struct Node * bottom;
	
	Node(int x)
	{
	    data = x;
	    next = NULL;
	    bottom = NULL;
	}
	
};

Node *merge(Node *a, Node *b)			//merge function
{
    if(a == NULL)return b;
    if(b == NULL)return a;
    
    Node *res;
    if(a->data < b->data)
    {
        res = a;
        res->bottom = merge(a->bottom, b);
    }
    else
    {
        res = b;
        res->bottom = merge(a, b->bottom);
    }
    res->next = NULL;
    return res;
}

Node *flatten(Node *root)			//flattened linked list fun
{
   if(root == NULL || root->next == NULL)
        return root;
        
    return merge(root, flatten(root->next));
}
---------------------------------------------------------------------------------
Q29) Sort a Linked List of 0's, 1's and 2's
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Node* segregate(Node *head) 
{
        
        int count[3] = {0,0,0};
        Node *curr = head;
        
        while(curr)
        {
            count[curr->data]++;
            curr = curr->next;
        }
        
        curr = head;
        int i = 0;
        while(curr)
        {
            if(count[i] == 0)
                i++;
                
            else
            {
                curr->data = i;
                count[i]--;
                curr = curr->next;
            }
        }
        return head;
}
---------------------------------------------------------------------------------
Q30) Clone a linked list with next and random pointer
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Node *copyList(Node *head)
{
        Node *curr = head, *temp;
        while(curr)
        {
            temp = curr->next;
            curr->next = new Node(curr->data);
            curr->next->next = temp;
            curr = temp;
        }
        
        curr = head;
        while(curr)
        {
            curr->next->arb = curr->arb? curr->arb->next:curr->arb;
            curr = curr->next->next;
        }
        
        Node *original = head;
        Node *copy = head->next;
        temp = copy;
        while(original && copy)
        {
            original->next = original->next->next;
            copy->next = copy->next? copy->next->next:copy->next;
            original = original->next;
            copy = copy->next;
        }
        return temp;
}
---------------------------------------------------------------------------------
Q31) Multiply two linked lists
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
long long  multiplyTwoLists (Node* l1, Node* l2)
{
  Node *p1 = l1, *p2 = l2;
  long long int num1 = 0, num2 = 0;
  long long mod = 1000000007;
  
  while(p1)
  {
      num1 = (num1*10 + (p1->data)) % mod;
      p1 = p1->next;
  }
  
  while(p2)
  {
      num2 = (num2*10 + (p2->data)) % mod;
      p2 = p2->next;
  }
  
  return (num1*num2) % mod;
}
---------------------------------------------------------------------------------
Q32) Delete nodes having greater value on right
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Node *reverse(Node *head)
{
        Node *curr = head, *prev = NULL, *next = NULL;
        while(curr)
        {
            next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
}
    
Node *compute(Node *head)
{
        head = reverse(head);
        int maxi = head->data;
        Node *prev = head, *curr = head->next;
        while(curr)
        {
            if(curr->data < maxi)
            {
                Node *next = curr->next;
                prev->next = next;
                curr = next;
            }
            else
            {
                prev = curr;
                curr = curr->next;
                maxi = prev->data;
            }
        }
        head = reverse(head);
        return head;
}
---------------------------------------------------------------------------------
Q33) Segregate even and odd nodes in a Link List 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Node* divide(int N, Node *head)
{
        Node *even = NULL, *e = NULL, *odd = NULL, *o = NULL;
        while(head)
        {
            if(head->data % 2 == 0)
            {
                if(even == NULL)
                {
                    even = head;
                    e = head;
                }
                else
                {
                    e->next = head;
                    e = e->next;
                }
            }
                
            else
            {
                if(odd == NULL)
                {
                    odd = head;
                    o = head;
                }
                else 
                {
                    o->next = head;
                    o = o->next;
                }
            }
            head = head->next;
            
        }
        if(e) e->next = odd;
        if(o) o->next = NULL;
        if(even) return even;
        else return odd;
}
---------------------------------------------------------------------------------
Q34) nth node from end of linked list 
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Node *reverse(Node *head)
{
    Node *curr = head, *prev = NULL, *next;
    while(curr)
    {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}

int getNthFromLast(Node *head, int n)
{
    head = reverse(head);
    int count = 1;
    while(head)
    {
        if(count == n && head)
        {
            return head->data;
        }
        else
        {
            count++;
            head = head->next;
        }
    }
    return -1;
}
---------------------------------------------------------------------------------
Q35) Sort a k sorted doubly linked list
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#include <bits/stdc++.h>
using namespace std;

struct Node                                             // struct node
{
	int data;
	struct Node* next;
	struct Node* prev;
};

struct compare                                          // struct compare
{
  bool operator()(Node *first, Node *second)
  {
    return first->data > second->data;
  }
};

Node *sortAKSortedDLL(Node *head, int k)                // sortAKSortedDLL
{
  if(head == NULL)return head;
  
  priority_queue<Node*, vector<Node*>, compare> pq;
  Node *new_head = NULL, *curr;

  for(int i=0; head && i <= k; i++)
  {
    pq.push(head);
    head = head->next;
  }
  
  while(!pq.empty())
  {
      if(new_head == NULL)
      {
          new_head = pq.top();
          new_head->prev = NULL;
          curr = new_head;
      }
      else
      {
          curr->next = pq.top();
          pq.top()->prev = curr;
          curr = pq.top();
      }
      pq.pop();
      
      if(head)
      {
          pq.push(head);
          head = head->next;
      }
  }
  curr->next = NULL;
  return new_head;
}

void push(Node** head_ref, int new_data)                    // insert a node at the beginning
{
	// allocate node
	Node* new_node = (Node*)malloc(sizeof(Node));

	// put in the data
	new_node->data = new_data;

	// since we are adding at the beginning,
	// prev is always NULL
	new_node->prev = NULL;

	// link the old list off the new node
	new_node->next = *head_ref;

	// change prev of head node to new node
	if (*head_ref != NULL)
		(*head_ref)->prev = new_node;

	// move the head to point to the new node
	*head_ref = new_node;
}


void printList(Node* head)                                      // printlist
{
	if (head == NULL)
		cout << "Doubly Linked list empty";

	while (head) 
	{
		cout << head->data << " ";
		head = head->next;
	}
}

int main()                                              	// main function
{
	Node* head = NULL;

	// Create the doubly linked list:
	// 3<->6<->2<->12<->56<->8
	push(&head, 8);
	push(&head, 56);
	push(&head, 12);
	push(&head, 2);
	push(&head, 6);
	push(&head, 3);

	int k = 2;

	cout << "Original Doubly linked list:\n";
	printList(head);

	head = sortAKSortedDLL(head, k);

	cout << "\nDoubly linked list after sorting:\n";
	printList(head);

	return 0;
}
***************************
Time Complexity: O(n*log k)
Auxiliary Space: O(k)
---------------------------------------------------------------------------------
Q36) merge K sorted linked list.
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    Node *merge(Node *a, Node *b)		//merge function
    {
        if(a == NULL) return b;
        if(b == NULL) return a;
       
        Node *head = NULL, *tail = NULL;
       
        if(a->data <= b->data)
        {
            head = a;
            tail = a;
            a = a->next;
        }
        else
        {
            head = b;
            tail = b;
            b = b->next;
        }
       
       
        while(a != NULL && b != NULL)
        {
            if(a->data <= b->data)
            {
                tail->next = a;
                tail = a;
                a = a->next;
            }
            else
            {
                tail->next = b;
                tail = b;
                b = b->next;
            }
           
        }
        if(a == NULL)
        {
            tail->next = b;
        }
        else
        {
            tail->next = a;
        }
       
        return head;
    }
   
  
    Node * mergeKLists(Node *arr[], int K)		//merge K sorted linked list
    {
        for(int i=0; i < K-1; i++)
        {
            arr[i+1] = merge(arr[i], arr[i+1]);
            
        }
        return arr[K-1];
    }
---------------------------------------------------------------------------------